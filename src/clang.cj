// This file is automatically generated. DO NOT EDIT.

package clang_cj

// cjlint-ignore -start !G.OTH.03 !G.NAM.03 !G.NAM.05 !G.VAR.01 !G.FUN.01 cjbind

/**
 * Error codes returned by libclang routines.
 *
 * Zero (\c CXError_Success) is the only error code indicating success.  Other
 * error codes, including not yet assigned non-zero values, indicate errors.
 */
type CXErrorCode = Int32

/**
   * No error.
   */
const CXError_Success: CXErrorCode = 0

/**
   * A generic error code, no further details are available.
   *
   * Errors of this kind can get their own specific error codes in future
   * libclang versions.
   */
const CXError_Failure: CXErrorCode = 1

/**
   * libclang crashed while performing the requested operation.
   */
const CXError_Crashed: CXErrorCode = 2

/**
   * The function detected that the arguments violate the function
   * contract.
   */
const CXError_InvalidArguments: CXErrorCode = 3

/**
   * An AST deserialization error has occurred.
   */
const CXError_ASTReadError: CXErrorCode = 4

/**
 * Retrieve the character data associated with the given string.
 */
foreign func clang_getCString(string: CXString): CString

/**
 * Free the given string.
 */
foreign func clang_disposeString(string: CXString): Unit

/**
 * Free the given string set.
 */
foreign func clang_disposeStringSet(set: CPointer<CXStringSet>): Unit

/**
 * Return the timestamp for use with Clang's
 * \c -fbuild-session-timestamp= option.
 */
foreign func clang_getBuildSessionTimestamp(): UInt64

/**
 * Create a \c CXVirtualFileOverlay object.
 * Must be disposed with \c clang_VirtualFileOverlay_dispose().
 *
 * \param options is reserved, always pass 0.
 */
foreign func clang_VirtualFileOverlay_create(options: UInt32): CPointer<CXVirtualFileOverlayImpl>

/**
 * Map an absolute virtual file path to an absolute real one.
 * The virtual path must be canonicalized (not contain "."/"..").
 * \returns 0 for success, non-zero to indicate an error.
 */
foreign func clang_VirtualFileOverlay_addFileMapping(arg0: CPointer<CXVirtualFileOverlayImpl>, virtualPath: CString, realPath: CString): CXErrorCode

/**
 * Set the case sensitivity for the \c CXVirtualFileOverlay object.
 * The \c CXVirtualFileOverlay object is case-sensitive by default, this
 * option can be used to override the default.
 * \returns 0 for success, non-zero to indicate an error.
 */
foreign func clang_VirtualFileOverlay_setCaseSensitivity(arg0: CPointer<CXVirtualFileOverlayImpl>, caseSensitive: Int32): CXErrorCode

/**
 * Write out the \c CXVirtualFileOverlay object to a char buffer.
 *
 * \param options is reserved, always pass 0.
 * \param out_buffer_ptr pointer to receive the buffer pointer, which should be
 * disposed using \c clang_free().
 * \param out_buffer_size pointer to receive the buffer size.
 * \returns 0 for success, non-zero to indicate an error.
 */
foreign func clang_VirtualFileOverlay_writeToBuffer(arg0: CPointer<CXVirtualFileOverlayImpl>, options: UInt32, out_buffer_ptr: CPointer<CString>, out_buffer_size: CPointer<UInt32>): CXErrorCode

/**
 * free memory allocated by libclang, such as the buffer returned by
 * \c CXVirtualFileOverlay() or \c clang_ModuleMapDescriptor_writeToBuffer().
 *
 * \param buffer memory pointer to free.
 */
foreign func clang_free(buffer: CPointer<Unit>): Unit

/**
 * Dispose a \c CXVirtualFileOverlay object.
 */
foreign func clang_VirtualFileOverlay_dispose(arg0: CPointer<CXVirtualFileOverlayImpl>): Unit

/**
 * Create a \c CXModuleMapDescriptor object.
 * Must be disposed with \c clang_ModuleMapDescriptor_dispose().
 *
 * \param options is reserved, always pass 0.
 */
foreign func clang_ModuleMapDescriptor_create(options: UInt32): CPointer<CXModuleMapDescriptorImpl>

/**
 * Sets the framework module name that the module.modulemap describes.
 * \returns 0 for success, non-zero to indicate an error.
 */
foreign func clang_ModuleMapDescriptor_setFrameworkModuleName(arg0: CPointer<CXModuleMapDescriptorImpl>, name: CString): CXErrorCode

/**
 * Sets the umbrella header name that the module.modulemap describes.
 * \returns 0 for success, non-zero to indicate an error.
 */
foreign func clang_ModuleMapDescriptor_setUmbrellaHeader(arg0: CPointer<CXModuleMapDescriptorImpl>, name: CString): CXErrorCode

/**
 * Write out the \c CXModuleMapDescriptor object to a char buffer.
 *
 * \param options is reserved, always pass 0.
 * \param out_buffer_ptr pointer to receive the buffer pointer, which should be
 * disposed using \c clang_free().
 * \param out_buffer_size pointer to receive the buffer size.
 * \returns 0 for success, non-zero to indicate an error.
 */
foreign func clang_ModuleMapDescriptor_writeToBuffer(arg0: CPointer<CXModuleMapDescriptorImpl>, options: UInt32, out_buffer_ptr: CPointer<CString>, out_buffer_size: CPointer<UInt32>): CXErrorCode

/**
 * Dispose a \c CXModuleMapDescriptor object.
 */
foreign func clang_ModuleMapDescriptor_dispose(arg0: CPointer<CXModuleMapDescriptorImpl>): Unit

/**
 * Retrieve the complete file and path name of the given file.
 */
foreign func clang_getFileName(SFile: CPointer<Unit>): CXString

/**
 * Retrieve the last modification time of the given file.
 */
foreign func clang_getFileTime(SFile: CPointer<Unit>): Int64

/**
 * Retrieve the unique ID for the given \c file.
 *
 * \param file the file to get the ID for.
 * \param outID stores the returned CXFileUniqueID.
 * \returns If there was a failure getting the unique ID, returns non-zero,
 * otherwise returns 0.
 */
foreign func clang_getFileUniqueID(file: CPointer<Unit>, outID: CPointer<CXFileUniqueID>): Int32

/**
 * Returns non-zero if the \c file1 and \c file2 point to the same file,
 * or they are both NULL.
 */
foreign func clang_File_isEqual(file1: CPointer<Unit>, file2: CPointer<Unit>): Int32

/**
 * Returns the real path name of \c file.
 *
 * An empty string may be returned. Use \c clang_getFileName() in that case.
 */
foreign func clang_File_tryGetRealPathName(file: CPointer<Unit>): CXString

/**
 * Retrieve a NULL (invalid) source location.
 */
foreign func clang_getNullLocation(): CXSourceLocation

/**
 * Determine whether two source locations, which must refer into
 * the same translation unit, refer to exactly the same point in the source
 * code.
 *
 * \returns non-zero if the source locations refer to the same location, zero
 * if they refer to different locations.
 */
foreign func clang_equalLocations(loc1: CXSourceLocation, loc2: CXSourceLocation): UInt32

/**
 * Determine for two source locations if the first comes
 * strictly before the second one in the source code.
 *
 * \returns non-zero if the first source location comes
 * strictly before the second one, zero otherwise.
 */
foreign func clang_isBeforeInTranslationUnit(loc1: CXSourceLocation, loc2: CXSourceLocation): UInt32

/**
 * Returns non-zero if the given source location is in a system header.
 */
foreign func clang_Location_isInSystemHeader(location: CXSourceLocation): Int32

/**
 * Returns non-zero if the given source location is in the main file of
 * the corresponding translation unit.
 */
foreign func clang_Location_isFromMainFile(location: CXSourceLocation): Int32

/**
 * Retrieve a NULL (invalid) source range.
 */
foreign func clang_getNullRange(): CXSourceRange

/**
 * Retrieve a source range given the beginning and ending source
 * locations.
 */
foreign func clang_getRange(begin: CXSourceLocation, end: CXSourceLocation): CXSourceRange

/**
 * Determine whether two ranges are equivalent.
 *
 * \returns non-zero if the ranges are the same, zero if they differ.
 */
foreign func clang_equalRanges(range1: CXSourceRange, range2: CXSourceRange): UInt32

/**
 * Returns non-zero if \p range is null.
 */
foreign func clang_Range_isNull(range: CXSourceRange): Int32

/**
 * Retrieve the file, line, column, and offset represented by
 * the given source location.
 *
 * If the location refers into a macro expansion, retrieves the
 * location of the macro expansion.
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param file [out] if non-NULL, will be set to the file to which the given
 * source location points.
 *
 * \param line [out] if non-NULL, will be set to the line to which the given
 * source location points.
 *
 * \param column [out] if non-NULL, will be set to the column to which the given
 * source location points.
 *
 * \param offset [out] if non-NULL, will be set to the offset into the
 * buffer to which the given source location points.
 */
foreign func clang_getExpansionLocation(location: CXSourceLocation, file: CPointer<CPointer<Unit>>, line: CPointer<UInt32>, column: CPointer<UInt32>, offset: CPointer<UInt32>): Unit

/**
 * Retrieve the file, line and column represented by the given source
 * location, as specified in a # line directive.
 *
 * Example: given the following source code in a file somefile.c
 *
 * \code
 * #123 "dummy.c" 1
 *
 * static int func(void)
 * {
 *     return 0;
 * }
 * \endcode
 *
 * the location information returned by this function would be
 *
 * File: dummy.c Line: 124 Column: 12
 *
 * whereas clang_getExpansionLocation would have returned
 *
 * File: somefile.c Line: 3 Column: 12
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param filename [out] if non-NULL, will be set to the filename of the
 * source location. Note that filenames returned will be for "virtual" files,
 * which don't necessarily exist on the machine running clang - e.g. when
 * parsing preprocessed output obtained from a different environment. If
 * a non-NULL value is passed in, remember to dispose of the returned value
 * using \c clang_disposeString() once you've finished with it. For an invalid
 * source location, an empty string is returned.
 *
 * \param line [out] if non-NULL, will be set to the line number of the
 * source location. For an invalid source location, zero is returned.
 *
 * \param column [out] if non-NULL, will be set to the column number of the
 * source location. For an invalid source location, zero is returned.
 */
foreign func clang_getPresumedLocation(location: CXSourceLocation, filename: CPointer<CXString>, line: CPointer<UInt32>, column: CPointer<UInt32>): Unit

/**
 * Legacy API to retrieve the file, line, column, and offset represented
 * by the given source location.
 *
 * This interface has been replaced by the newer interface
 * #clang_getExpansionLocation(). See that interface's documentation for
 * details.
 */
foreign func clang_getInstantiationLocation(location: CXSourceLocation, file: CPointer<CPointer<Unit>>, line: CPointer<UInt32>, column: CPointer<UInt32>, offset: CPointer<UInt32>): Unit

/**
 * Retrieve the file, line, column, and offset represented by
 * the given source location.
 *
 * If the location refers into a macro instantiation, return where the
 * location was originally spelled in the source file.
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param file [out] if non-NULL, will be set to the file to which the given
 * source location points.
 *
 * \param line [out] if non-NULL, will be set to the line to which the given
 * source location points.
 *
 * \param column [out] if non-NULL, will be set to the column to which the given
 * source location points.
 *
 * \param offset [out] if non-NULL, will be set to the offset into the
 * buffer to which the given source location points.
 */
foreign func clang_getSpellingLocation(location: CXSourceLocation, file: CPointer<CPointer<Unit>>, line: CPointer<UInt32>, column: CPointer<UInt32>, offset: CPointer<UInt32>): Unit

/**
 * Retrieve the file, line, column, and offset represented by
 * the given source location.
 *
 * If the location refers into a macro expansion, return where the macro was
 * expanded or where the macro argument was written, if the location points at
 * a macro argument.
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param file [out] if non-NULL, will be set to the file to which the given
 * source location points.
 *
 * \param line [out] if non-NULL, will be set to the line to which the given
 * source location points.
 *
 * \param column [out] if non-NULL, will be set to the column to which the given
 * source location points.
 *
 * \param offset [out] if non-NULL, will be set to the offset into the
 * buffer to which the given source location points.
 */
foreign func clang_getFileLocation(location: CXSourceLocation, file: CPointer<CPointer<Unit>>, line: CPointer<UInt32>, column: CPointer<UInt32>, offset: CPointer<UInt32>): Unit

/**
 * Retrieve a source location representing the first character within a
 * source range.
 */
foreign func clang_getRangeStart(range: CXSourceRange): CXSourceLocation

/**
 * Retrieve a source location representing the last character within a
 * source range.
 */
foreign func clang_getRangeEnd(range: CXSourceRange): CXSourceLocation

/**
 * Destroy the given \c CXSourceRangeList.
 */
foreign func clang_disposeSourceRangeList(ranges: CPointer<CXSourceRangeList>): Unit

/**
 * Describes the severity of a particular diagnostic.
 */
type CXDiagnosticSeverity = Int32

/**
   * A diagnostic that has been suppressed, e.g., by a command-line
   * option.
   */
const CXDiagnostic_Ignored: CXDiagnosticSeverity = 0

/**
   * This diagnostic is a note that should be attached to the
   * previous (non-note) diagnostic.
   */
const CXDiagnostic_Note: CXDiagnosticSeverity = 1

/**
   * This diagnostic indicates suspicious code that may not be
   * wrong.
   */
const CXDiagnostic_Warning: CXDiagnosticSeverity = 2

/**
   * This diagnostic indicates that the code is ill-formed.
   */
const CXDiagnostic_Error: CXDiagnosticSeverity = 3

/**
   * This diagnostic indicates that the code is ill-formed such
   * that future parser recovery is unlikely to produce useful
   * results.
   */
const CXDiagnostic_Fatal: CXDiagnosticSeverity = 4

/**
 * Determine the number of diagnostics in a CXDiagnosticSet.
 */
foreign func clang_getNumDiagnosticsInSet(Diags: CPointer<Unit>): UInt32

/**
 * Retrieve a diagnostic associated with the given CXDiagnosticSet.
 *
 * \param Diags the CXDiagnosticSet to query.
 * \param Index the zero-based diagnostic number to retrieve.
 *
 * \returns the requested diagnostic. This diagnostic must be freed
 * via a call to \c clang_disposeDiagnostic().
 */
foreign func clang_getDiagnosticInSet(Diags: CPointer<Unit>, Index: UInt32): CPointer<Unit>

/**
 * Describes the kind of error that occurred (if any) in a call to
 * \c clang_loadDiagnostics.
 */
type CXLoadDiag_Error = Int32

/**
   * Indicates that no error occurred.
   */
const CXLoadDiag_None: CXLoadDiag_Error = 0

/**
   * Indicates that an unknown error occurred while attempting to
   * deserialize diagnostics.
   */
const CXLoadDiag_Unknown: CXLoadDiag_Error = 1

/**
   * Indicates that the file containing the serialized diagnostics
   * could not be opened.
   */
const CXLoadDiag_CannotLoad: CXLoadDiag_Error = 2

/**
   * Indicates that the serialized diagnostics file is invalid or
   * corrupt.
   */
const CXLoadDiag_InvalidFile: CXLoadDiag_Error = 3

/**
 * Deserialize a set of diagnostics from a Clang diagnostics bitcode
 * file.
 *
 * \param file The name of the file to deserialize.
 * \param error A pointer to a enum value recording if there was a problem
 *        deserializing the diagnostics.
 * \param errorString A pointer to a CXString for recording the error string
 *        if the file was not successfully loaded.
 *
 * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These
 * diagnostics should be released using clang_disposeDiagnosticSet().
 */
foreign func clang_loadDiagnostics(file: CString, error: CPointer<CXLoadDiag_Error>, errorString: CPointer<CXString>): CPointer<Unit>

/**
 * Release a CXDiagnosticSet and all of its contained diagnostics.
 */
foreign func clang_disposeDiagnosticSet(Diags: CPointer<Unit>): Unit

/**
 * Retrieve the child diagnostics of a CXDiagnostic.
 *
 * This CXDiagnosticSet does not need to be released by
 * clang_disposeDiagnosticSet.
 */
foreign func clang_getChildDiagnostics(D: CPointer<Unit>): CPointer<Unit>

/**
 * Destroy a diagnostic.
 */
foreign func clang_disposeDiagnostic(Diagnostic: CPointer<Unit>): Unit

/**
 * Options to control the display of diagnostics.
 *
 * The values in this enum are meant to be combined to customize the
 * behavior of \c clang_formatDiagnostic().
 */
type CXDiagnosticDisplayOptions = Int32

/**
   * Display the source-location information where the
   * diagnostic was located.
   *
   * When set, diagnostics will be prefixed by the file, line, and
   * (optionally) column to which the diagnostic refers. For example,
   *
   * \code
   * test.c:28: warning: extra tokens at end of #endif directive
   * \endcode
   *
   * This option corresponds to the clang flag \c -fshow-source-location.
   */
const CXDiagnostic_DisplaySourceLocation: CXDiagnosticDisplayOptions = 1

/**
   * If displaying the source-location information of the
   * diagnostic, also include the column number.
   *
   * This option corresponds to the clang flag \c -fshow-column.
   */
const CXDiagnostic_DisplayColumn: CXDiagnosticDisplayOptions = 2

/**
   * If displaying the source-location information of the
   * diagnostic, also include information about source ranges in a
   * machine-parsable format.
   *
   * This option corresponds to the clang flag
   * \c -fdiagnostics-print-source-range-info.
   */
const CXDiagnostic_DisplaySourceRanges: CXDiagnosticDisplayOptions = 4

/**
   * Display the option name associated with this diagnostic, if any.
   *
   * The option name displayed (e.g., -Wconversion) will be placed in brackets
   * after the diagnostic text. This option corresponds to the clang flag
   * \c -fdiagnostics-show-option.
   */
const CXDiagnostic_DisplayOption: CXDiagnosticDisplayOptions = 8

/**
   * Display the category number associated with this diagnostic, if any.
   *
   * The category number is displayed within brackets after the diagnostic text.
   * This option corresponds to the clang flag
   * \c -fdiagnostics-show-category=id.
   */
const CXDiagnostic_DisplayCategoryId: CXDiagnosticDisplayOptions = 16

/**
   * Display the category name associated with this diagnostic, if any.
   *
   * The category name is displayed within brackets after the diagnostic text.
   * This option corresponds to the clang flag
   * \c -fdiagnostics-show-category=name.
   */
const CXDiagnostic_DisplayCategoryName: CXDiagnosticDisplayOptions = 32

/**
 * Format the given diagnostic in a manner that is suitable for display.
 *
 * This routine will format the given diagnostic to a string, rendering
 * the diagnostic according to the various options given. The
 * \c clang_defaultDiagnosticDisplayOptions() function returns the set of
 * options that most closely mimics the behavior of the clang compiler.
 *
 * \param Diagnostic The diagnostic to print.
 *
 * \param Options A set of options that control the diagnostic display,
 * created by combining \c CXDiagnosticDisplayOptions values.
 *
 * \returns A new string containing for formatted diagnostic.
 */
foreign func clang_formatDiagnostic(Diagnostic: CPointer<Unit>, Options: UInt32): CXString

/**
 * Retrieve the set of display options most similar to the
 * default behavior of the clang compiler.
 *
 * \returns A set of display options suitable for use with \c
 * clang_formatDiagnostic().
 */
foreign func clang_defaultDiagnosticDisplayOptions(): UInt32

/**
 * Determine the severity of the given diagnostic.
 */
foreign func clang_getDiagnosticSeverity(arg0: CPointer<Unit>): CXDiagnosticSeverity

/**
 * Retrieve the source location of the given diagnostic.
 *
 * This location is where Clang would print the caret ('^') when
 * displaying the diagnostic on the command line.
 */
foreign func clang_getDiagnosticLocation(arg0: CPointer<Unit>): CXSourceLocation

/**
 * Retrieve the text of the given diagnostic.
 */
foreign func clang_getDiagnosticSpelling(arg0: CPointer<Unit>): CXString

/**
 * Retrieve the name of the command-line option that enabled this
 * diagnostic.
 *
 * \param Diag The diagnostic to be queried.
 *
 * \param Disable If non-NULL, will be set to the option that disables this
 * diagnostic (if any).
 *
 * \returns A string that contains the command-line option used to enable this
 * warning, such as "-Wconversion" or "-pedantic".
 */
foreign func clang_getDiagnosticOption(Diag: CPointer<Unit>, Disable: CPointer<CXString>): CXString

/**
 * Retrieve the category number for this diagnostic.
 *
 * Diagnostics can be categorized into groups along with other, related
 * diagnostics (e.g., diagnostics under the same warning flag). This routine
 * retrieves the category number for the given diagnostic.
 *
 * \returns The number of the category that contains this diagnostic, or zero
 * if this diagnostic is uncategorized.
 */
foreign func clang_getDiagnosticCategory(arg0: CPointer<Unit>): UInt32

/**
 * Retrieve the name of a particular diagnostic category.  This
 *  is now deprecated.  Use clang_getDiagnosticCategoryText()
 *  instead.
 *
 * \param Category A diagnostic category number, as returned by
 * \c clang_getDiagnosticCategory().
 *
 * \returns The name of the given diagnostic category.
 */
foreign func clang_getDiagnosticCategoryName(Category: UInt32): CXString

/**
 * Retrieve the diagnostic category text for a given diagnostic.
 *
 * \returns The text of the given diagnostic category.
 */
foreign func clang_getDiagnosticCategoryText(arg0: CPointer<Unit>): CXString

/**
 * Determine the number of source ranges associated with the given
 * diagnostic.
 */
foreign func clang_getDiagnosticNumRanges(arg0: CPointer<Unit>): UInt32

/**
 * Retrieve a source range associated with the diagnostic.
 *
 * A diagnostic's source ranges highlight important elements in the source
 * code. On the command line, Clang displays source ranges by
 * underlining them with '~' characters.
 *
 * \param Diagnostic the diagnostic whose range is being extracted.
 *
 * \param Range the zero-based index specifying which range to
 *
 * \returns the requested source range.
 */
foreign func clang_getDiagnosticRange(Diagnostic: CPointer<Unit>, Range: UInt32): CXSourceRange

/**
 * Determine the number of fix-it hints associated with the
 * given diagnostic.
 */
foreign func clang_getDiagnosticNumFixIts(Diagnostic: CPointer<Unit>): UInt32

/**
 * Retrieve the replacement information for a given fix-it.
 *
 * Fix-its are described in terms of a source range whose contents
 * should be replaced by a string. This approach generalizes over
 * three kinds of operations: removal of source code (the range covers
 * the code to be removed and the replacement string is empty),
 * replacement of source code (the range covers the code to be
 * replaced and the replacement string provides the new code), and
 * insertion (both the start and end of the range point at the
 * insertion location, and the replacement string provides the text to
 * insert).
 *
 * \param Diagnostic The diagnostic whose fix-its are being queried.
 *
 * \param FixIt The zero-based index of the fix-it.
 *
 * \param ReplacementRange The source range whose contents will be
 * replaced with the returned replacement string. Note that source
 * ranges are half-open ranges [a, b), so the source code should be
 * replaced from a and up to (but not including) b.
 *
 * \returns A string containing text that should be replace the source
 * code indicated by the \c ReplacementRange.
 */
foreign func clang_getDiagnosticFixIt(Diagnostic: CPointer<Unit>, FixIt: UInt32, ReplacementRange: CPointer<CXSourceRange>): CXString

/**
 * Describes the availability of a particular entity, which indicates
 * whether the use of this entity will result in a warning or error due to
 * it being deprecated or unavailable.
 */
type CXAvailabilityKind = Int32

/**
   * The entity is available.
   */
const CXAvailability_Available: CXAvailabilityKind = 0

/**
   * The entity is available, but has been deprecated (and its use is
   * not recommended).
   */
const CXAvailability_Deprecated: CXAvailabilityKind = 1

/**
   * The entity is not available; any use of it will be an error.
   */
const CXAvailability_NotAvailable: CXAvailabilityKind = 2

/**
   * The entity is available, but not accessible; any use of it will be
   * an error.
   */
const CXAvailability_NotAccessible: CXAvailabilityKind = 3

/**
 * Describes the exception specification of a cursor.
 *
 * A negative value indicates that the cursor is not a function declaration.
 */
type CXCursor_ExceptionSpecificationKind = Int32

/**
   * The cursor has no exception specification.
   */
const CXCursor_ExceptionSpecificationKind_None: CXCursor_ExceptionSpecificationKind = 0

/**
   * The cursor has exception specification throw()
   */
const CXCursor_ExceptionSpecificationKind_DynamicNone: CXCursor_ExceptionSpecificationKind = 1

/**
   * The cursor has exception specification throw(T1, T2)
   */
const CXCursor_ExceptionSpecificationKind_Dynamic: CXCursor_ExceptionSpecificationKind = 2

/**
   * The cursor has exception specification throw(...).
   */
const CXCursor_ExceptionSpecificationKind_MSAny: CXCursor_ExceptionSpecificationKind = 3

/**
   * The cursor has exception specification basic noexcept.
   */
const CXCursor_ExceptionSpecificationKind_BasicNoexcept: CXCursor_ExceptionSpecificationKind = 4

/**
   * The cursor has exception specification computed noexcept.
   */
const CXCursor_ExceptionSpecificationKind_ComputedNoexcept: CXCursor_ExceptionSpecificationKind = 5

/**
   * The exception specification has not yet been evaluated.
   */
const CXCursor_ExceptionSpecificationKind_Unevaluated: CXCursor_ExceptionSpecificationKind = 6

/**
   * The exception specification has not yet been instantiated.
   */
const CXCursor_ExceptionSpecificationKind_Uninstantiated: CXCursor_ExceptionSpecificationKind = 7

/**
   * The exception specification has not been parsed yet.
   */
const CXCursor_ExceptionSpecificationKind_Unparsed: CXCursor_ExceptionSpecificationKind = 8

/**
   * The cursor has a __declspec(nothrow) exception specification.
   */
const CXCursor_ExceptionSpecificationKind_NoThrow: CXCursor_ExceptionSpecificationKind = 9

/**
 * Provides a shared context for creating translation units.
 *
 * It provides two options:
 *
 * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of "local"
 * declarations (when loading any new translation units). A "local" declaration
 * is one that belongs in the translation unit itself and not in a precompiled
 * header that was used by the translation unit. If zero, all declarations
 * will be enumerated.
 *
 * Here is an example:
 *
 * \code
 *   // excludeDeclsFromPCH = 1, displayDiagnostics=1
 *   Idx = clang_createIndex(1, 1);
 *
 *   // IndexTest.pch was produced with the following command:
 *   // "clang -x c IndexTest.h -emit-ast -o IndexTest.pch"
 *   TU = clang_createTranslationUnit(Idx, "IndexTest.pch");
 *
 *   // This will load all the symbols from 'IndexTest.pch'
 *   clang_visitChildren(clang_getTranslationUnitCursor(TU),
 *                       TranslationUnitVisitor, 0);
 *   clang_disposeTranslationUnit(TU);
 *
 *   // This will load all the symbols from 'IndexTest.c', excluding symbols
 *   // from 'IndexTest.pch'.
 *   char *args[] = { "-Xclang", "-include-pch=IndexTest.pch" };
 *   TU = clang_createTranslationUnitFromSourceFile(Idx, "IndexTest.c", 2, args,
 *                                                  0, 0);
 *   clang_visitChildren(clang_getTranslationUnitCursor(TU),
 *                       TranslationUnitVisitor, 0);
 *   clang_disposeTranslationUnit(TU);
 * \endcode
 *
 * This process of creating the 'pch', loading it separately, and using it (via
 * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks
 * (which gives the indexer the same performance benefit as the compiler).
 */
foreign func clang_createIndex(excludeDeclarationsFromPCH: Int32, displayDiagnostics: Int32): CPointer<Unit>

/**
 * Destroy the given index.
 *
 * The index must not be destroyed until all of the translation units created
 * within that index have been destroyed.
 */
foreign func clang_disposeIndex(index: CPointer<Unit>): Unit

type CXChoice = Int32

/**
   * Use the default value of an option that may depend on the process
   * environment.
   */
const CXChoice_Default: CXChoice = 0

/**
   * Enable the option.
   */
const CXChoice_Enabled: CXChoice = 1

/**
   * Disable the option.
   */
const CXChoice_Disabled: CXChoice = 2

type CXGlobalOptFlags = Int32

/**
   * Used to indicate that no special CXIndex options are needed.
   */
const CXGlobalOpt_None: CXGlobalOptFlags = 0

/**
   * Used to indicate that threads that libclang creates for indexing
   * purposes should use background priority.
   *
   * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,
   * #clang_parseTranslationUnit, #clang_saveTranslationUnit.
   */
const CXGlobalOpt_ThreadBackgroundPriorityForIndexing: CXGlobalOptFlags = 1

/**
   * Used to indicate that threads that libclang creates for editing
   * purposes should use background priority.
   *
   * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,
   * #clang_annotateTokens
   */
const CXGlobalOpt_ThreadBackgroundPriorityForEditing: CXGlobalOptFlags = 2

/**
   * Used to indicate that all threads that libclang creates should use
   * background priority.
   */
const CXGlobalOpt_ThreadBackgroundPriorityForAll: CXGlobalOptFlags = 3

/**
 * Provides a shared context for creating translation units.
 *
 * Call this function instead of clang_createIndex() if you need to configure
 * the additional options in CXIndexOptions.
 *
 * \returns The created index or null in case of error, such as an unsupported
 * value of options->Size.
 *
 * For example:
 * \code
 * CXIndex createIndex(const char *ApplicationTemporaryPath) {
 *   const int ExcludeDeclarationsFromPCH = 1;
 *   const int DisplayDiagnostics = 1;
 *   CXIndex Idx;
 * #if CINDEX_VERSION_MINOR >= 64
 *   CXIndexOptions Opts;
 *   memset(&Opts, 0, sizeof(Opts));
 *   Opts.Size = sizeof(CXIndexOptions);
 *   Opts.ThreadBackgroundPriorityForIndexing = 1;
 *   Opts.ExcludeDeclarationsFromPCH = ExcludeDeclarationsFromPCH;
 *   Opts.DisplayDiagnostics = DisplayDiagnostics;
 *   Opts.PreambleStoragePath = ApplicationTemporaryPath;
 *   Idx = clang_createIndexWithOptions(&Opts);
 *   if (Idx)
 *     return Idx;
 *   fprintf(stderr,
 *           "clang_createIndexWithOptions() failed. "
 *           "CINDEX_VERSION_MINOR = %d, sizeof(CXIndexOptions) = %u\n",
 *           CINDEX_VERSION_MINOR, Opts.Size);
 * #else
 *   (void)ApplicationTemporaryPath;
 * #endif
 *   Idx = clang_createIndex(ExcludeDeclarationsFromPCH, DisplayDiagnostics);
 *   clang_CXIndex_setGlobalOptions(
 *       Idx, clang_CXIndex_getGlobalOptions(Idx) |
 *                CXGlobalOpt_ThreadBackgroundPriorityForIndexing);
 *   return Idx;
 * }
 * \endcode
 *
 * \sa clang_createIndex()
 */
foreign func clang_createIndexWithOptions(options: CPointer<CXIndexOptions>): CPointer<Unit>

/**
 * Sets general options associated with a CXIndex.
 *
 * This function is DEPRECATED. Set
 * CXIndexOptions::ThreadBackgroundPriorityForIndexing and/or
 * CXIndexOptions::ThreadBackgroundPriorityForEditing and call
 * clang_createIndexWithOptions() instead.
 *
 * For example:
 * \code
 * CXIndex idx = ...;
 * clang_CXIndex_setGlobalOptions(idx,
 *     clang_CXIndex_getGlobalOptions(idx) |
 *     CXGlobalOpt_ThreadBackgroundPriorityForIndexing);
 * \endcode
 *
 * \param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.
 */
foreign func clang_CXIndex_setGlobalOptions(arg0: CPointer<Unit>, options: UInt32): Unit

/**
 * Gets the general options associated with a CXIndex.
 *
 * This function allows to obtain the final option values used by libclang after
 * specifying the option policies via CXChoice enumerators.
 *
 * \returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that
 * are associated with the given CXIndex object.
 */
foreign func clang_CXIndex_getGlobalOptions(arg0: CPointer<Unit>): UInt32

/**
 * Sets the invocation emission path option in a CXIndex.
 *
 * This function is DEPRECATED. Set CXIndexOptions::InvocationEmissionPath and
 * call clang_createIndexWithOptions() instead.
 *
 * The invocation emission path specifies a path which will contain log
 * files for certain libclang invocations. A null value (default) implies that
 * libclang invocations are not logged..
 */
foreign func clang_CXIndex_setInvocationEmissionPathOption(arg0: CPointer<Unit>, Path: CString): Unit

/**
 * Determine whether the given header is guarded against
 * multiple inclusions, either with the conventional
 * \#ifndef/\#define/\#endif macro guards or with \#pragma once.
 */
foreign func clang_isFileMultipleIncludeGuarded(tu: CPointer<CXTranslationUnitImpl>, file: CPointer<Unit>): UInt32

/**
 * Retrieve a file handle within the given translation unit.
 *
 * \param tu the translation unit
 *
 * \param file_name the name of the file.
 *
 * \returns the file handle for the named file in the translation unit \p tu,
 * or a NULL file handle if the file was not a part of this translation unit.
 */
foreign func clang_getFile(tu: CPointer<CXTranslationUnitImpl>, file_name: CString): CPointer<Unit>

/**
 * Retrieve the buffer associated with the given file.
 *
 * \param tu the translation unit
 *
 * \param file the file for which to retrieve the buffer.
 *
 * \param size [out] if non-NULL, will be set to the size of the buffer.
 *
 * \returns a pointer to the buffer in memory that holds the contents of
 * \p file, or a NULL pointer when the file is not loaded.
 */
foreign func clang_getFileContents(tu: CPointer<CXTranslationUnitImpl>, file: CPointer<Unit>, size: CPointer<UInt64>): CString

/**
 * Retrieves the source location associated with a given file/line/column
 * in a particular translation unit.
 */
foreign func clang_getLocation(tu: CPointer<CXTranslationUnitImpl>, file: CPointer<Unit>, line: UInt32, column: UInt32): CXSourceLocation

/**
 * Retrieves the source location associated with a given character offset
 * in a particular translation unit.
 */
foreign func clang_getLocationForOffset(tu: CPointer<CXTranslationUnitImpl>, file: CPointer<Unit>, offset: UInt32): CXSourceLocation

/**
 * Retrieve all ranges that were skipped by the preprocessor.
 *
 * The preprocessor will skip lines when they are surrounded by an
 * if/ifdef/ifndef directive whose condition does not evaluate to true.
 */
foreign func clang_getSkippedRanges(tu: CPointer<CXTranslationUnitImpl>, file: CPointer<Unit>): CPointer<CXSourceRangeList>

/**
 * Retrieve all ranges from all files that were skipped by the
 * preprocessor.
 *
 * The preprocessor will skip lines when they are surrounded by an
 * if/ifdef/ifndef directive whose condition does not evaluate to true.
 */
foreign func clang_getAllSkippedRanges(tu: CPointer<CXTranslationUnitImpl>): CPointer<CXSourceRangeList>

/**
 * Determine the number of diagnostics produced for the given
 * translation unit.
 */
foreign func clang_getNumDiagnostics(Unit_: CPointer<CXTranslationUnitImpl>): UInt32

/**
 * Retrieve a diagnostic associated with the given translation unit.
 *
 * \param Unit the translation unit to query.
 * \param Index the zero-based diagnostic number to retrieve.
 *
 * \returns the requested diagnostic. This diagnostic must be freed
 * via a call to \c clang_disposeDiagnostic().
 */
foreign func clang_getDiagnostic(Unit_: CPointer<CXTranslationUnitImpl>, Index: UInt32): CPointer<Unit>

/**
 * Retrieve the complete set of diagnostics associated with a
 *        translation unit.
 *
 * \param Unit the translation unit to query.
 */
foreign func clang_getDiagnosticSetFromTU(Unit_: CPointer<CXTranslationUnitImpl>): CPointer<Unit>

/**
 * Get the original translation unit source file name.
 */
foreign func clang_getTranslationUnitSpelling(CTUnit: CPointer<CXTranslationUnitImpl>): CXString

/**
 * Return the CXTranslationUnit for a given source file and the provided
 * command line arguments one would pass to the compiler.
 *
 * Note: The 'source_filename' argument is optional.  If the caller provides a
 * NULL pointer, the name of the source file is expected to reside in the
 * specified command line arguments.
 *
 * Note: When encountered in 'clang_command_line_args', the following options
 * are ignored:
 *
 *   '-c'
 *   '-emit-ast'
 *   '-fsyntax-only'
 *   '-o \<output file>'  (both '-o' and '\<output file>' are ignored)
 *
 * \param CIdx The index object with which the translation unit will be
 * associated.
 *
 * \param source_filename The name of the source file to load, or NULL if the
 * source file is included in \p clang_command_line_args.
 *
 * \param num_clang_command_line_args The number of command-line arguments in
 * \p clang_command_line_args.
 *
 * \param clang_command_line_args The command-line arguments that would be
 * passed to the \c clang executable if it were being invoked out-of-process.
 * These command-line options will be parsed and will affect how the translation
 * unit is parsed. Note that the following options are ignored: '-c',
 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.
 *
 * \param num_unsaved_files the number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param unsaved_files the files that have not yet been saved to disk
 * but may be required for code completion, including the contents of
 * those files.  The contents and name of these files (as specified by
 * CXUnsavedFile) are copied when necessary, so the client only needs to
 * guarantee their validity until the call to this function returns.
 */
foreign func clang_createTranslationUnitFromSourceFile(CIdx: CPointer<Unit>, source_filename: CString, num_clang_command_line_args: Int32, clang_command_line_args: CPointer<CString>, num_unsaved_files: UInt32, unsaved_files: CPointer<CXUnsavedFile>): CPointer<CXTranslationUnitImpl>

/**
 * Same as \c clang_createTranslationUnit2, but returns
 * the \c CXTranslationUnit instead of an error code.  In case of an error this
 * routine returns a \c NULL \c CXTranslationUnit, without further detailed
 * error codes.
 */
foreign func clang_createTranslationUnit(CIdx: CPointer<Unit>, ast_filename: CString): CPointer<CXTranslationUnitImpl>

/**
 * Create a translation unit from an AST file (\c -emit-ast).
 *
 * \param[out] out_TU A non-NULL pointer to store the created
 * \c CXTranslationUnit.
 *
 * \returns Zero on success, otherwise returns an error code.
 */
foreign func clang_createTranslationUnit2(CIdx: CPointer<Unit>, ast_filename: CString, out_TU: CPointer<CPointer<CXTranslationUnitImpl>>): CXErrorCode

/**
 * Flags that control the creation of translation units.
 *
 * The enumerators in this enumeration type are meant to be bitwise
 * ORed together to specify which options should be used when
 * constructing the translation unit.
 */
type CXTranslationUnit_Flags = Int32

/**
   * Used to indicate that no special translation-unit options are
   * needed.
   */
const CXTranslationUnit_None: CXTranslationUnit_Flags = 0

/**
   * Used to indicate that the parser should construct a "detailed"
   * preprocessing record, including all macro definitions and instantiations.
   *
   * Constructing a detailed preprocessing record requires more memory
   * and time to parse, since the information contained in the record
   * is usually not retained. However, it can be useful for
   * applications that require more detailed information about the
   * behavior of the preprocessor.
   */
const CXTranslationUnit_DetailedPreprocessingRecord: CXTranslationUnit_Flags = 1

/**
   * Used to indicate that the translation unit is incomplete.
   *
   * When a translation unit is considered "incomplete", semantic
   * analysis that is typically performed at the end of the
   * translation unit will be suppressed. For example, this suppresses
   * the completion of tentative declarations in C and of
   * instantiation of implicitly-instantiation function templates in
   * C++. This option is typically used when parsing a header with the
   * intent of producing a precompiled header.
   */
const CXTranslationUnit_Incomplete: CXTranslationUnit_Flags = 2

/**
   * Used to indicate that the translation unit should be built with an
   * implicit precompiled header for the preamble.
   *
   * An implicit precompiled header is used as an optimization when a
   * particular translation unit is likely to be reparsed many times
   * when the sources aren't changing that often. In this case, an
   * implicit precompiled header will be built containing all of the
   * initial includes at the top of the main file (what we refer to as
   * the "preamble" of the file). In subsequent parses, if the
   * preamble or the files in it have not changed, \c
   * clang_reparseTranslationUnit() will re-use the implicit
   * precompiled header to improve parsing performance.
   */
const CXTranslationUnit_PrecompiledPreamble: CXTranslationUnit_Flags = 4

/**
   * Used to indicate that the translation unit should cache some
   * code-completion results with each reparse of the source file.
   *
   * Caching of code-completion results is a performance optimization that
   * introduces some overhead to reparsing but improves the performance of
   * code-completion operations.
   */
const CXTranslationUnit_CacheCompletionResults: CXTranslationUnit_Flags = 8

/**
   * Used to indicate that the translation unit will be serialized with
   * \c clang_saveTranslationUnit.
   *
   * This option is typically used when parsing a header with the intent of
   * producing a precompiled header.
   */
const CXTranslationUnit_ForSerialization: CXTranslationUnit_Flags = 16

/**
   * DEPRECATED: Enabled chained precompiled preambles in C++.
   *
   * Note: this is a *temporary* option that is available only while
   * we are testing C++ precompiled preamble support. It is deprecated.
   */
const CXTranslationUnit_CXXChainedPCH: CXTranslationUnit_Flags = 32

/**
   * Used to indicate that function/method bodies should be skipped while
   * parsing.
   *
   * This option can be used to search for declarations/definitions while
   * ignoring the usages.
   */
const CXTranslationUnit_SkipFunctionBodies: CXTranslationUnit_Flags = 64

/**
   * Used to indicate that brief documentation comments should be
   * included into the set of code completions returned from this translation
   * unit.
   */
const CXTranslationUnit_IncludeBriefCommentsInCodeCompletion: CXTranslationUnit_Flags = 128

/**
   * Used to indicate that the precompiled preamble should be created on
   * the first parse. Otherwise it will be created on the first reparse. This
   * trades runtime on the first parse (serializing the preamble takes time) for
   * reduced runtime on the second parse (can now reuse the preamble).
   */
const CXTranslationUnit_CreatePreambleOnFirstParse: CXTranslationUnit_Flags = 256

/**
   * Do not stop processing when fatal errors are encountered.
   *
   * When fatal errors are encountered while parsing a translation unit,
   * semantic analysis is typically stopped early when compiling code. A common
   * source for fatal errors are unresolvable include files. For the
   * purposes of an IDE, this is undesirable behavior and as much information
   * as possible should be reported. Use this flag to enable this behavior.
   */
const CXTranslationUnit_KeepGoing: CXTranslationUnit_Flags = 512

/**
   * Sets the preprocessor in a mode for parsing a single file only.
   */
const CXTranslationUnit_SingleFileParse: CXTranslationUnit_Flags = 1024

/**
   * Used in combination with CXTranslationUnit_SkipFunctionBodies to
   * constrain the skipping of function bodies to the preamble.
   *
   * The function bodies of the main file are not skipped.
   */
const CXTranslationUnit_LimitSkipFunctionBodiesToPreamble: CXTranslationUnit_Flags = 2048

/**
   * Used to indicate that attributed types should be included in CXType.
   */
const CXTranslationUnit_IncludeAttributedTypes: CXTranslationUnit_Flags = 4096

/**
   * Used to indicate that implicit attributes should be visited.
   */
const CXTranslationUnit_VisitImplicitAttributes: CXTranslationUnit_Flags = 8192

/**
   * Used to indicate that non-errors from included files should be ignored.
   *
   * If set, clang_getDiagnosticSetFromTU() will not report e.g. warnings from
   * included files anymore. This speeds up clang_getDiagnosticSetFromTU() for
   * the case where these warnings are not of interest, as for an IDE for
   * example, which typically shows only the diagnostics in the main file.
   */
const CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles: CXTranslationUnit_Flags = 16384

/**
   * Tells the preprocessor not to skip excluded conditional blocks.
   */
const CXTranslationUnit_RetainExcludedConditionalBlocks: CXTranslationUnit_Flags = 32768

/**
 * Returns the set of flags that is suitable for parsing a translation
 * unit that is being edited.
 *
 * The set of flags returned provide options for \c clang_parseTranslationUnit()
 * to indicate that the translation unit is likely to be reparsed many times,
 * either explicitly (via \c clang_reparseTranslationUnit()) or implicitly
 * (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag
 * set contains an unspecified set of optimizations (e.g., the precompiled
 * preamble) geared toward improving the performance of these routines. The
 * set of optimizations enabled may change from one version to the next.
 */
foreign func clang_defaultEditingTranslationUnitOptions(): UInt32

/**
 * Same as \c clang_parseTranslationUnit2, but returns
 * the \c CXTranslationUnit instead of an error code.  In case of an error this
 * routine returns a \c NULL \c CXTranslationUnit, without further detailed
 * error codes.
 */
foreign func clang_parseTranslationUnit(CIdx: CPointer<Unit>, source_filename: CString, command_line_args: CPointer<CString>, num_command_line_args: Int32, unsaved_files: CPointer<CXUnsavedFile>, num_unsaved_files: UInt32, options: UInt32): CPointer<CXTranslationUnitImpl>

/**
 * Parse the given source file and the translation unit corresponding
 * to that file.
 *
 * This routine is the main entry point for the Clang C API, providing the
 * ability to parse a source file into a translation unit that can then be
 * queried by other functions in the API. This routine accepts a set of
 * command-line arguments so that the compilation can be configured in the same
 * way that the compiler is configured on the command line.
 *
 * \param CIdx The index object with which the translation unit will be
 * associated.
 *
 * \param source_filename The name of the source file to load, or NULL if the
 * source file is included in \c command_line_args.
 *
 * \param command_line_args The command-line arguments that would be
 * passed to the \c clang executable if it were being invoked out-of-process.
 * These command-line options will be parsed and will affect how the translation
 * unit is parsed. Note that the following options are ignored: '-c',
 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.
 *
 * \param num_command_line_args The number of command-line arguments in
 * \c command_line_args.
 *
 * \param unsaved_files the files that have not yet been saved to disk
 * but may be required for parsing, including the contents of
 * those files.  The contents and name of these files (as specified by
 * CXUnsavedFile) are copied when necessary, so the client only needs to
 * guarantee their validity until the call to this function returns.
 *
 * \param num_unsaved_files the number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param options A bitmask of options that affects how the translation unit
 * is managed but not its compilation. This should be a bitwise OR of the
 * CXTranslationUnit_XXX flags.
 *
 * \param[out] out_TU A non-NULL pointer to store the created
 * \c CXTranslationUnit, describing the parsed code and containing any
 * diagnostics produced by the compiler.
 *
 * \returns Zero on success, otherwise returns an error code.
 */
foreign func clang_parseTranslationUnit2(CIdx: CPointer<Unit>, source_filename: CString, command_line_args: CPointer<CString>, num_command_line_args: Int32, unsaved_files: CPointer<CXUnsavedFile>, num_unsaved_files: UInt32, options: UInt32, out_TU: CPointer<CPointer<CXTranslationUnitImpl>>): CXErrorCode

/**
 * Same as clang_parseTranslationUnit2 but requires a full command line
 * for \c command_line_args including argv[0]. This is useful if the standard
 * library paths are relative to the binary.
 */
foreign func clang_parseTranslationUnit2FullArgv(CIdx: CPointer<Unit>, source_filename: CString, command_line_args: CPointer<CString>, num_command_line_args: Int32, unsaved_files: CPointer<CXUnsavedFile>, num_unsaved_files: UInt32, options: UInt32, out_TU: CPointer<CPointer<CXTranslationUnitImpl>>): CXErrorCode

/**
 * Flags that control how translation units are saved.
 *
 * The enumerators in this enumeration type are meant to be bitwise
 * ORed together to specify which options should be used when
 * saving the translation unit.
 */
type CXSaveTranslationUnit_Flags = Int32

/**
   * Used to indicate that no special saving options are needed.
   */
const CXSaveTranslationUnit_None: CXSaveTranslationUnit_Flags = 0

/**
 * Returns the set of flags that is suitable for saving a translation
 * unit.
 *
 * The set of flags returned provide options for
 * \c clang_saveTranslationUnit() by default. The returned flag
 * set contains an unspecified set of options that save translation units with
 * the most commonly-requested data.
 */
foreign func clang_defaultSaveOptions(TU: CPointer<CXTranslationUnitImpl>): UInt32

/**
 * Describes the kind of error that occurred (if any) in a call to
 * \c clang_saveTranslationUnit().
 */
type CXSaveError = Int32

/**
   * Indicates that no error occurred while saving a translation unit.
   */
const CXSaveError_None: CXSaveError = 0

/**
   * Indicates that an unknown error occurred while attempting to save
   * the file.
   *
   * This error typically indicates that file I/O failed when attempting to
   * write the file.
   */
const CXSaveError_Unknown: CXSaveError = 1

/**
   * Indicates that errors during translation prevented this attempt
   * to save the translation unit.
   *
   * Errors that prevent the translation unit from being saved can be
   * extracted using \c clang_getNumDiagnostics() and \c clang_getDiagnostic().
   */
const CXSaveError_TranslationErrors: CXSaveError = 2

/**
   * Indicates that the translation unit to be saved was somehow
   * invalid (e.g., NULL).
   */
const CXSaveError_InvalidTU: CXSaveError = 3

/**
 * Saves a translation unit into a serialized representation of
 * that translation unit on disk.
 *
 * Any translation unit that was parsed without error can be saved
 * into a file. The translation unit can then be deserialized into a
 * new \c CXTranslationUnit with \c clang_createTranslationUnit() or,
 * if it is an incomplete translation unit that corresponds to a
 * header, used as a precompiled header when parsing other translation
 * units.
 *
 * \param TU The translation unit to save.
 *
 * \param FileName The file to which the translation unit will be saved.
 *
 * \param options A bitmask of options that affects how the translation unit
 * is saved. This should be a bitwise OR of the
 * CXSaveTranslationUnit_XXX flags.
 *
 * \returns A value that will match one of the enumerators of the CXSaveError
 * enumeration. Zero (CXSaveError_None) indicates that the translation unit was
 * saved successfully, while a non-zero value indicates that a problem occurred.
 */
foreign func clang_saveTranslationUnit(TU: CPointer<CXTranslationUnitImpl>, FileName: CString, options: UInt32): Int32

/**
 * Suspend a translation unit in order to free memory associated with it.
 *
 * A suspended translation unit uses significantly less memory but on the other
 * side does not support any other calls than \c clang_reparseTranslationUnit
 * to resume it or \c clang_disposeTranslationUnit to dispose it completely.
 */
foreign func clang_suspendTranslationUnit(arg0: CPointer<CXTranslationUnitImpl>): UInt32

/**
 * Destroy the specified CXTranslationUnit object.
 */
foreign func clang_disposeTranslationUnit(arg0: CPointer<CXTranslationUnitImpl>): Unit

/**
 * Flags that control the reparsing of translation units.
 *
 * The enumerators in this enumeration type are meant to be bitwise
 * ORed together to specify which options should be used when
 * reparsing the translation unit.
 */
type CXReparse_Flags = Int32

/**
   * Used to indicate that no special reparsing options are needed.
   */
const CXReparse_None: CXReparse_Flags = 0

/**
 * Returns the set of flags that is suitable for reparsing a translation
 * unit.
 *
 * The set of flags returned provide options for
 * \c clang_reparseTranslationUnit() by default. The returned flag
 * set contains an unspecified set of optimizations geared toward common uses
 * of reparsing. The set of optimizations enabled may change from one version
 * to the next.
 */
foreign func clang_defaultReparseOptions(TU: CPointer<CXTranslationUnitImpl>): UInt32

/**
 * Reparse the source files that produced this translation unit.
 *
 * This routine can be used to re-parse the source files that originally
 * created the given translation unit, for example because those source files
 * have changed (either on disk or as passed via \p unsaved_files). The
 * source code will be reparsed with the same command-line options as it
 * was originally parsed.
 *
 * Reparsing a translation unit invalidates all cursors and source locations
 * that refer into that translation unit. This makes reparsing a translation
 * unit semantically equivalent to destroying the translation unit and then
 * creating a new translation unit with the same command-line arguments.
 * However, it may be more efficient to reparse a translation
 * unit using this routine.
 *
 * \param TU The translation unit whose contents will be re-parsed. The
 * translation unit must originally have been built with
 * \c clang_createTranslationUnitFromSourceFile().
 *
 * \param num_unsaved_files The number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param unsaved_files The files that have not yet been saved to disk
 * but may be required for parsing, including the contents of
 * those files.  The contents and name of these files (as specified by
 * CXUnsavedFile) are copied when necessary, so the client only needs to
 * guarantee their validity until the call to this function returns.
 *
 * \param options A bitset of options composed of the flags in CXReparse_Flags.
 * The function \c clang_defaultReparseOptions() produces a default set of
 * options recommended for most uses, based on the translation unit.
 *
 * \returns 0 if the sources could be reparsed.  A non-zero error code will be
 * returned if reparsing was impossible, such that the translation unit is
 * invalid. In such cases, the only valid call for \c TU is
 * \c clang_disposeTranslationUnit(TU).  The error codes returned by this
 * routine are described by the \c CXErrorCode enum.
 */
foreign func clang_reparseTranslationUnit(TU: CPointer<CXTranslationUnitImpl>, num_unsaved_files: UInt32, unsaved_files: CPointer<CXUnsavedFile>, options: UInt32): Int32

/**
 * Categorizes how memory is being used by a translation unit.
 */
type CXTUResourceUsageKind = Int32

const CXTUResourceUsage_AST: CXTUResourceUsageKind = 1

const CXTUResourceUsage_Identifiers: CXTUResourceUsageKind = 2

const CXTUResourceUsage_Selectors: CXTUResourceUsageKind = 3

const CXTUResourceUsage_GlobalCompletionResults: CXTUResourceUsageKind = 4

const CXTUResourceUsage_SourceManagerContentCache: CXTUResourceUsageKind = 5

const CXTUResourceUsage_AST_SideTables: CXTUResourceUsageKind = 6

const CXTUResourceUsage_SourceManager_Membuffer_Malloc: CXTUResourceUsageKind = 7

const CXTUResourceUsage_SourceManager_Membuffer_MMap: CXTUResourceUsageKind = 8

const CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc: CXTUResourceUsageKind = 9

const CXTUResourceUsage_ExternalASTSource_Membuffer_MMap: CXTUResourceUsageKind = 10

const CXTUResourceUsage_Preprocessor: CXTUResourceUsageKind = 11

const CXTUResourceUsage_PreprocessingRecord: CXTUResourceUsageKind = 12

const CXTUResourceUsage_SourceManager_DataStructures: CXTUResourceUsageKind = 13

const CXTUResourceUsage_Preprocessor_HeaderSearch: CXTUResourceUsageKind = 14

const CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN: CXTUResourceUsageKind = 1

const CXTUResourceUsage_MEMORY_IN_BYTES_END: CXTUResourceUsageKind = 14

const CXTUResourceUsage_First: CXTUResourceUsageKind = 1

const CXTUResourceUsage_Last: CXTUResourceUsageKind = 14

/**
 * Returns the human-readable null-terminated C string that represents
 *  the name of the memory category.  This string should never be freed.
 */
foreign func clang_getTUResourceUsageName(kind: CXTUResourceUsageKind): CString

/**
 * Return the memory usage of a translation unit.  This object
 *  should be released with clang_disposeCXTUResourceUsage().
 */
foreign func clang_getCXTUResourceUsage(TU: CPointer<CXTranslationUnitImpl>): CXTUResourceUsage

foreign func clang_disposeCXTUResourceUsage(usage: CXTUResourceUsage): Unit

/**
 * Get target information for this translation unit.
 *
 * The CXTargetInfo object cannot outlive the CXTranslationUnit object.
 */
foreign func clang_getTranslationUnitTargetInfo(CTUnit: CPointer<CXTranslationUnitImpl>): CPointer<CXTargetInfoImpl>

/**
 * Destroy the CXTargetInfo object.
 */
foreign func clang_TargetInfo_dispose(Info: CPointer<CXTargetInfoImpl>): Unit

/**
 * Get the normalized target triple as a string.
 *
 * Returns the empty string in case of any error.
 */
foreign func clang_TargetInfo_getTriple(Info: CPointer<CXTargetInfoImpl>): CXString

/**
 * Get the pointer width of the target in bits.
 *
 * Returns -1 in case of error.
 */
foreign func clang_TargetInfo_getPointerWidth(Info: CPointer<CXTargetInfoImpl>): Int32

/**
 * Describes the kind of entity that a cursor refers to.
 */
type CXCursorKind = Int32

/**
   * A declaration whose specific kind is not exposed via this
   * interface.
   *
   * Unexposed declarations have the same operations as any other kind
   * of declaration; one can extract their location information,
   * spelling, find their definitions, etc. However, the specific kind
   * of the declaration is not reported.
   */
const CXCursor_UnexposedDecl: CXCursorKind = 1

/** A C or C++ struct. */
const CXCursor_StructDecl: CXCursorKind = 2

/** A C or C++ union. */
const CXCursor_UnionDecl: CXCursorKind = 3

/** A C++ class. */
const CXCursor_ClassDecl: CXCursorKind = 4

/** An enumeration. */
const CXCursor_EnumDecl: CXCursorKind = 5

/**
   * A field (in C) or non-static data member (in C++) in a
   * struct, union, or C++ class.
   */
const CXCursor_FieldDecl: CXCursorKind = 6

/** An enumerator constant. */
const CXCursor_EnumConstantDecl: CXCursorKind = 7

/** A function. */
const CXCursor_FunctionDecl: CXCursorKind = 8

/** A variable. */
const CXCursor_VarDecl: CXCursorKind = 9

/** A function or method parameter. */
const CXCursor_ParmDecl: CXCursorKind = 10

/** An Objective-C \@interface. */
const CXCursor_ObjCInterfaceDecl: CXCursorKind = 11

/** An Objective-C \@interface for a category. */
const CXCursor_ObjCCategoryDecl: CXCursorKind = 12

/** An Objective-C \@protocol declaration. */
const CXCursor_ObjCProtocolDecl: CXCursorKind = 13

/** An Objective-C \@property declaration. */
const CXCursor_ObjCPropertyDecl: CXCursorKind = 14

/** An Objective-C instance variable. */
const CXCursor_ObjCIvarDecl: CXCursorKind = 15

/** An Objective-C instance method. */
const CXCursor_ObjCInstanceMethodDecl: CXCursorKind = 16

/** An Objective-C class method. */
const CXCursor_ObjCClassMethodDecl: CXCursorKind = 17

/** An Objective-C \@implementation. */
const CXCursor_ObjCImplementationDecl: CXCursorKind = 18

/** An Objective-C \@implementation for a category. */
const CXCursor_ObjCCategoryImplDecl: CXCursorKind = 19

/** A typedef. */
const CXCursor_TypedefDecl: CXCursorKind = 20

/** A C++ class method. */
const CXCursor_CXXMethod: CXCursorKind = 21

/** A C++ namespace. */
const CXCursor_Namespace: CXCursorKind = 22

/** A linkage specification, e.g. 'extern "C"'. */
const CXCursor_LinkageSpec: CXCursorKind = 23

/** A C++ constructor. */
const CXCursor_Constructor: CXCursorKind = 24

/** A C++ destructor. */
const CXCursor_Destructor: CXCursorKind = 25

/** A C++ conversion function. */
const CXCursor_ConversionFunction: CXCursorKind = 26

/** A C++ template type parameter. */
const CXCursor_TemplateTypeParameter: CXCursorKind = 27

/** A C++ non-type template parameter. */
const CXCursor_NonTypeTemplateParameter: CXCursorKind = 28

/** A C++ template template parameter. */
const CXCursor_TemplateTemplateParameter: CXCursorKind = 29

/** A C++ function template. */
const CXCursor_FunctionTemplate: CXCursorKind = 30

/** A C++ class template. */
const CXCursor_ClassTemplate: CXCursorKind = 31

/** A C++ class template partial specialization. */
const CXCursor_ClassTemplatePartialSpecialization: CXCursorKind = 32

/** A C++ namespace alias declaration. */
const CXCursor_NamespaceAlias: CXCursorKind = 33

/** A C++ using directive. */
const CXCursor_UsingDirective: CXCursorKind = 34

/** A C++ using declaration. */
const CXCursor_UsingDeclaration: CXCursorKind = 35

/** A C++ alias declaration */
const CXCursor_TypeAliasDecl: CXCursorKind = 36

/** An Objective-C \@synthesize definition. */
const CXCursor_ObjCSynthesizeDecl: CXCursorKind = 37

/** An Objective-C \@dynamic definition. */
const CXCursor_ObjCDynamicDecl: CXCursorKind = 38

/** An access specifier. */
const CXCursor_CXXAccessSpecifier: CXCursorKind = 39

/** An access specifier. */
const CXCursor_FirstDecl: CXCursorKind = 1

/** An access specifier. */
const CXCursor_LastDecl: CXCursorKind = 39

/** An access specifier. */
const CXCursor_FirstRef: CXCursorKind = 40

/** An access specifier. */
const CXCursor_ObjCSuperClassRef: CXCursorKind = 40

/** An access specifier. */
const CXCursor_ObjCProtocolRef: CXCursorKind = 41

/** An access specifier. */
const CXCursor_ObjCClassRef: CXCursorKind = 42

/**
   * A reference to a type declaration.
   *
   * A type reference occurs anywhere where a type is named but not
   * declared. For example, given:
   *
   * \code
   * typedef unsigned size_type;
   * size_type size;
   * \endcode
   *
   * The typedef is a declaration of size_type (CXCursor_TypedefDecl),
   * while the type of the variable "size" is referenced. The cursor
   * referenced by the type of size is the typedef for size_type.
   */
const CXCursor_TypeRef: CXCursorKind = 43

/**
   * A reference to a type declaration.
   *
   * A type reference occurs anywhere where a type is named but not
   * declared. For example, given:
   *
   * \code
   * typedef unsigned size_type;
   * size_type size;
   * \endcode
   *
   * The typedef is a declaration of size_type (CXCursor_TypedefDecl),
   * while the type of the variable "size" is referenced. The cursor
   * referenced by the type of size is the typedef for size_type.
   */
const CXCursor_CXXBaseSpecifier: CXCursorKind = 44

/**
   * A reference to a class template, function template, template
   * template parameter, or class template partial specialization.
   */
const CXCursor_TemplateRef: CXCursorKind = 45

/**
   * A reference to a namespace or namespace alias.
   */
const CXCursor_NamespaceRef: CXCursorKind = 46

/**
   * A reference to a member of a struct, union, or class that occurs in
   * some non-expression context, e.g., a designated initializer.
   */
const CXCursor_MemberRef: CXCursorKind = 47

/**
   * A reference to a labeled statement.
   *
   * This cursor kind is used to describe the jump to "start_over" in the
   * goto statement in the following example:
   *
   * \code
   *   start_over:
   *     ++counter;
   *
   *     goto start_over;
   * \endcode
   *
   * A label reference cursor refers to a label statement.
   */
const CXCursor_LabelRef: CXCursorKind = 48

/**
   * A reference to a set of overloaded functions or function templates
   * that has not yet been resolved to a specific function or function template.
   *
   * An overloaded declaration reference cursor occurs in C++ templates where
   * a dependent name refers to a function. For example:
   *
   * \code
   * template<typename T> void swap(T&, T&);
   *
   * struct X { ... };
   * void swap(X&, X&);
   *
   * template<typename T>
   * void reverse(T* first, T* last) {
   *   while (first < last - 1) {
   *     swap(*first, *--last);
   *     ++first;
   *   }
   * }
   *
   * struct Y { };
   * void swap(Y&, Y&);
   * \endcode
   *
   * Here, the identifier "swap" is associated with an overloaded declaration
   * reference. In the template definition, "swap" refers to either of the two
   * "swap" functions declared above, so both results will be available. At
   * instantiation time, "swap" may also refer to other functions found via
   * argument-dependent lookup (e.g., the "swap" function at the end of the
   * example).
   *
   * The functions \c clang_getNumOverloadedDecls() and
   * \c clang_getOverloadedDecl() can be used to retrieve the definitions
   * referenced by this cursor.
   */
const CXCursor_OverloadedDeclRef: CXCursorKind = 49

/**
   * A reference to a variable that occurs in some non-expression
   * context, e.g., a C++ lambda capture list.
   */
const CXCursor_VariableRef: CXCursorKind = 50

/**
   * A reference to a variable that occurs in some non-expression
   * context, e.g., a C++ lambda capture list.
   */
const CXCursor_LastRef: CXCursorKind = 50

/**
   * A reference to a variable that occurs in some non-expression
   * context, e.g., a C++ lambda capture list.
   */
const CXCursor_FirstInvalid: CXCursorKind = 70

/**
   * A reference to a variable that occurs in some non-expression
   * context, e.g., a C++ lambda capture list.
   */
const CXCursor_InvalidFile: CXCursorKind = 70

/**
   * A reference to a variable that occurs in some non-expression
   * context, e.g., a C++ lambda capture list.
   */
const CXCursor_NoDeclFound: CXCursorKind = 71

/**
   * A reference to a variable that occurs in some non-expression
   * context, e.g., a C++ lambda capture list.
   */
const CXCursor_NotImplemented: CXCursorKind = 72

/**
   * A reference to a variable that occurs in some non-expression
   * context, e.g., a C++ lambda capture list.
   */
const CXCursor_InvalidCode: CXCursorKind = 73

/**
   * A reference to a variable that occurs in some non-expression
   * context, e.g., a C++ lambda capture list.
   */
const CXCursor_LastInvalid: CXCursorKind = 73

/**
   * A reference to a variable that occurs in some non-expression
   * context, e.g., a C++ lambda capture list.
   */
const CXCursor_FirstExpr: CXCursorKind = 100

/**
   * An expression whose specific kind is not exposed via this
   * interface.
   *
   * Unexposed expressions have the same operations as any other kind
   * of expression; one can extract their location information,
   * spelling, children, etc. However, the specific kind of the
   * expression is not reported.
   */
const CXCursor_UnexposedExpr: CXCursorKind = 100

/**
   * An expression that refers to some value declaration, such
   * as a function, variable, or enumerator.
   */
const CXCursor_DeclRefExpr: CXCursorKind = 101

/**
   * An expression that refers to a member of a struct, union,
   * class, Objective-C class, etc.
   */
const CXCursor_MemberRefExpr: CXCursorKind = 102

/** An expression that calls a function. */
const CXCursor_CallExpr: CXCursorKind = 103

/** An expression that sends a message to an Objective-C
   object or class. */
const CXCursor_ObjCMessageExpr: CXCursorKind = 104

/** An expression that represents a block literal. */
const CXCursor_BlockExpr: CXCursorKind = 105

/** An integer literal.
   */
const CXCursor_IntegerLiteral: CXCursorKind = 106

/** A floating point number literal.
   */
const CXCursor_FloatingLiteral: CXCursorKind = 107

/** An imaginary number literal.
   */
const CXCursor_ImaginaryLiteral: CXCursorKind = 108

/** A string literal.
   */
const CXCursor_StringLiteral: CXCursorKind = 109

/** A character literal.
   */
const CXCursor_CharacterLiteral: CXCursorKind = 110

/** A parenthesized expression, e.g. "(1)".
   *
   * This AST node is only formed if full location information is requested.
   */
const CXCursor_ParenExpr: CXCursorKind = 111

/** This represents the unary-expression's (except sizeof and
   * alignof).
   */
const CXCursor_UnaryOperator: CXCursorKind = 112

/** [C99 6.5.2.1] Array Subscripting.
   */
const CXCursor_ArraySubscriptExpr: CXCursorKind = 113

/** A builtin binary operation expression such as "x + y" or
   * "x <= y".
   */
const CXCursor_BinaryOperator: CXCursorKind = 114

/** Compound assignment such as "+=".
   */
const CXCursor_CompoundAssignOperator: CXCursorKind = 115

/** The ?: ternary operator.
   */
const CXCursor_ConditionalOperator: CXCursorKind = 116

/** An explicit cast in C (C99 6.5.4) or a C-style cast in C++
   * (C++ [expr.cast]), which uses the syntax (Type)expr.
   *
   * For example: (int)f.
   */
const CXCursor_CStyleCastExpr: CXCursorKind = 117

/** [C99 6.5.2.5]
   */
const CXCursor_CompoundLiteralExpr: CXCursorKind = 118

/** Describes an C or C++ initializer list.
   */
const CXCursor_InitListExpr: CXCursorKind = 119

/** The GNU address of label extension, representing &&label.
   */
const CXCursor_AddrLabelExpr: CXCursorKind = 120

/** This is the GNU Statement Expression extension: ({int X=4; X;})
   */
const CXCursor_StmtExpr: CXCursorKind = 121

/** Represents a C11 generic selection.
   */
const CXCursor_GenericSelectionExpr: CXCursorKind = 122

/** Implements the GNU __null extension, which is a name for a null
   * pointer constant that has integral type (e.g., int or long) and is the same
   * size and alignment as a pointer.
   *
   * The __null extension is typically only used by system headers, which define
   * NULL as __null in C++ rather than using 0 (which is an integer that may not
   * match the size of a pointer).
   */
const CXCursor_GNUNullExpr: CXCursorKind = 123

/** C++'s static_cast<> expression.
   */
const CXCursor_CXXStaticCastExpr: CXCursorKind = 124

/** C++'s dynamic_cast<> expression.
   */
const CXCursor_CXXDynamicCastExpr: CXCursorKind = 125

/** C++'s reinterpret_cast<> expression.
   */
const CXCursor_CXXReinterpretCastExpr: CXCursorKind = 126

/** C++'s const_cast<> expression.
   */
const CXCursor_CXXConstCastExpr: CXCursorKind = 127

/** Represents an explicit C++ type conversion that uses "functional"
   * notion (C++ [expr.type.conv]).
   *
   * Example:
   * \code
   *   x = int(0.5);
   * \endcode
   */
const CXCursor_CXXFunctionalCastExpr: CXCursorKind = 128

/** A C++ typeid expression (C++ [expr.typeid]).
   */
const CXCursor_CXXTypeidExpr: CXCursorKind = 129

/** [C++ 2.13.5] C++ Boolean Literal.
   */
const CXCursor_CXXBoolLiteralExpr: CXCursorKind = 130

/** [C++0x 2.14.7] C++ Pointer Literal.
   */
const CXCursor_CXXNullPtrLiteralExpr: CXCursorKind = 131

/** Represents the "this" expression in C++
   */
const CXCursor_CXXThisExpr: CXCursorKind = 132

/** [C++ 15] C++ Throw Expression.
   *
   * This handles 'throw' and 'throw' assignment-expression. When
   * assignment-expression isn't present, Op will be null.
   */
const CXCursor_CXXThrowExpr: CXCursorKind = 133

/** A new expression for memory allocation and constructor calls, e.g:
   * "new CXXNewExpr(foo)".
   */
const CXCursor_CXXNewExpr: CXCursorKind = 134

/** A delete expression for memory deallocation and destructor calls,
   * e.g. "delete[] pArray".
   */
const CXCursor_CXXDeleteExpr: CXCursorKind = 135

/** A unary expression. (noexcept, sizeof, or other traits)
   */
const CXCursor_UnaryExpr: CXCursorKind = 136

/** An Objective-C string literal i.e. @"foo".
   */
const CXCursor_ObjCStringLiteral: CXCursorKind = 137

/** An Objective-C \@encode expression.
   */
const CXCursor_ObjCEncodeExpr: CXCursorKind = 138

/** An Objective-C \@selector expression.
   */
const CXCursor_ObjCSelectorExpr: CXCursorKind = 139

/** An Objective-C \@protocol expression.
   */
const CXCursor_ObjCProtocolExpr: CXCursorKind = 140

/** An Objective-C "bridged" cast expression, which casts between
   * Objective-C pointers and C pointers, transferring ownership in the process.
   *
   * \code
   *   NSString *str = (__bridge_transfer NSString *)CFCreateString();
   * \endcode
   */
const CXCursor_ObjCBridgedCastExpr: CXCursorKind = 141

/** Represents a C++0x pack expansion that produces a sequence of
   * expressions.
   *
   * A pack expansion expression contains a pattern (which itself is an
   * expression) followed by an ellipsis. For example:
   *
   * \code
   * template<typename F, typename ...Types>
   * void forward(F f, Types &&...args) {
   *  f(static_cast<Types&&>(args)...);
   * }
   * \endcode
   */
const CXCursor_PackExpansionExpr: CXCursorKind = 142

/** Represents an expression that computes the length of a parameter
   * pack.
   *
   * \code
   * template<typename ...Types>
   * struct count {
   *   static const unsigned value = sizeof...(Types);
   * };
   * \endcode
   */
const CXCursor_SizeOfPackExpr: CXCursorKind = 143

const CXCursor_LambdaExpr: CXCursorKind = 144

/** Objective-c Boolean Literal.
   */
const CXCursor_ObjCBoolLiteralExpr: CXCursorKind = 145

/** Represents the "self" expression in an Objective-C method.
   */
const CXCursor_ObjCSelfExpr: CXCursorKind = 146

/** OpenMP 5.0 [2.1.5, Array Section].
   * OpenACC 3.3 [2.7.1, Data Specification for Data Clauses (Sub Arrays)]
   */
const CXCursor_ArraySectionExpr: CXCursorKind = 147

/** Represents an @available(...) check.
   */
const CXCursor_ObjCAvailabilityCheckExpr: CXCursorKind = 148

/**
   * Fixed point literal
   */
const CXCursor_FixedPointLiteral: CXCursorKind = 149

/** OpenMP 5.0 [2.1.4, Array Shaping].
   */
const CXCursor_OMPArrayShapingExpr: CXCursorKind = 150

/**
   * OpenMP 5.0 [2.1.6 Iterators]
   */
const CXCursor_OMPIteratorExpr: CXCursorKind = 151

/** OpenCL's addrspace_cast<> expression.
   */
const CXCursor_CXXAddrspaceCastExpr: CXCursorKind = 152

/**
   * Expression that references a C++20 concept.
   */
const CXCursor_ConceptSpecializationExpr: CXCursorKind = 153

/**
   * Expression that references a C++20 requires expression.
   */
const CXCursor_RequiresExpr: CXCursorKind = 154

/**
   * Expression that references a C++20 parenthesized list aggregate
   * initializer.
   */
const CXCursor_CXXParenListInitExpr: CXCursorKind = 155

/**
   *  Represents a C++26 pack indexing expression.
   */
const CXCursor_PackIndexingExpr: CXCursorKind = 156

/**
   *  Represents a C++26 pack indexing expression.
   */
const CXCursor_LastExpr: CXCursorKind = 156

/**
   *  Represents a C++26 pack indexing expression.
   */
const CXCursor_FirstStmt: CXCursorKind = 200

/**
   * A statement whose specific kind is not exposed via this
   * interface.
   *
   * Unexposed statements have the same operations as any other kind of
   * statement; one can extract their location information, spelling,
   * children, etc. However, the specific kind of the statement is not
   * reported.
   */
const CXCursor_UnexposedStmt: CXCursorKind = 200

/** A labelled statement in a function.
   *
   * This cursor kind is used to describe the "start_over:" label statement in
   * the following example:
   *
   * \code
   *   start_over:
   *     ++counter;
   * \endcode
   *
   */
const CXCursor_LabelStmt: CXCursorKind = 201

/** A group of statements like { stmt stmt }.
   *
   * This cursor kind is used to describe compound statements, e.g. function
   * bodies.
   */
const CXCursor_CompoundStmt: CXCursorKind = 202

/** A case statement.
   */
const CXCursor_CaseStmt: CXCursorKind = 203

/** A default statement.
   */
const CXCursor_DefaultStmt: CXCursorKind = 204

/** An if statement
   */
const CXCursor_IfStmt: CXCursorKind = 205

/** A switch statement.
   */
const CXCursor_SwitchStmt: CXCursorKind = 206

/** A while statement.
   */
const CXCursor_WhileStmt: CXCursorKind = 207

/** A do statement.
   */
const CXCursor_DoStmt: CXCursorKind = 208

/** A for statement.
   */
const CXCursor_ForStmt: CXCursorKind = 209

/** A goto statement.
   */
const CXCursor_GotoStmt: CXCursorKind = 210

/** An indirect goto statement.
   */
const CXCursor_IndirectGotoStmt: CXCursorKind = 211

/** A continue statement.
   */
const CXCursor_ContinueStmt: CXCursorKind = 212

/** A break statement.
   */
const CXCursor_BreakStmt: CXCursorKind = 213

/** A return statement.
   */
const CXCursor_ReturnStmt: CXCursorKind = 214

/** A GCC inline assembly statement extension.
   */
const CXCursor_GCCAsmStmt: CXCursorKind = 215

/** A GCC inline assembly statement extension.
   */
const CXCursor_AsmStmt: CXCursorKind = 215

/** Objective-C's overall \@try-\@catch-\@finally statement.
   */
const CXCursor_ObjCAtTryStmt: CXCursorKind = 216

/** Objective-C's \@catch statement.
   */
const CXCursor_ObjCAtCatchStmt: CXCursorKind = 217

/** Objective-C's \@finally statement.
   */
const CXCursor_ObjCAtFinallyStmt: CXCursorKind = 218

/** Objective-C's \@throw statement.
   */
const CXCursor_ObjCAtThrowStmt: CXCursorKind = 219

/** Objective-C's \@synchronized statement.
   */
const CXCursor_ObjCAtSynchronizedStmt: CXCursorKind = 220

/** Objective-C's autorelease pool statement.
   */
const CXCursor_ObjCAutoreleasePoolStmt: CXCursorKind = 221

/** Objective-C's collection statement.
   */
const CXCursor_ObjCForCollectionStmt: CXCursorKind = 222

/** C++'s catch statement.
   */
const CXCursor_CXXCatchStmt: CXCursorKind = 223

/** C++'s try statement.
   */
const CXCursor_CXXTryStmt: CXCursorKind = 224

/** C++'s for (* : *) statement.
   */
const CXCursor_CXXForRangeStmt: CXCursorKind = 225

/** Windows Structured Exception Handling's try statement.
   */
const CXCursor_SEHTryStmt: CXCursorKind = 226

/** Windows Structured Exception Handling's except statement.
   */
const CXCursor_SEHExceptStmt: CXCursorKind = 227

/** Windows Structured Exception Handling's finally statement.
   */
const CXCursor_SEHFinallyStmt: CXCursorKind = 228

/** A MS inline assembly statement extension.
   */
const CXCursor_MSAsmStmt: CXCursorKind = 229

/** The null statement ";": C99 6.8.3p3.
   *
   * This cursor kind is used to describe the null statement.
   */
const CXCursor_NullStmt: CXCursorKind = 230

/** Adaptor class for mixing declarations with statements and
   * expressions.
   */
const CXCursor_DeclStmt: CXCursorKind = 231

/** OpenMP parallel directive.
   */
const CXCursor_OMPParallelDirective: CXCursorKind = 232

/** OpenMP SIMD directive.
   */
const CXCursor_OMPSimdDirective: CXCursorKind = 233

/** OpenMP for directive.
   */
const CXCursor_OMPForDirective: CXCursorKind = 234

/** OpenMP sections directive.
   */
const CXCursor_OMPSectionsDirective: CXCursorKind = 235

/** OpenMP section directive.
   */
const CXCursor_OMPSectionDirective: CXCursorKind = 236

/** OpenMP single directive.
   */
const CXCursor_OMPSingleDirective: CXCursorKind = 237

/** OpenMP parallel for directive.
   */
const CXCursor_OMPParallelForDirective: CXCursorKind = 238

/** OpenMP parallel sections directive.
   */
const CXCursor_OMPParallelSectionsDirective: CXCursorKind = 239

/** OpenMP task directive.
   */
const CXCursor_OMPTaskDirective: CXCursorKind = 240

/** OpenMP master directive.
   */
const CXCursor_OMPMasterDirective: CXCursorKind = 241

/** OpenMP critical directive.
   */
const CXCursor_OMPCriticalDirective: CXCursorKind = 242

/** OpenMP taskyield directive.
   */
const CXCursor_OMPTaskyieldDirective: CXCursorKind = 243

/** OpenMP barrier directive.
   */
const CXCursor_OMPBarrierDirective: CXCursorKind = 244

/** OpenMP taskwait directive.
   */
const CXCursor_OMPTaskwaitDirective: CXCursorKind = 245

/** OpenMP flush directive.
   */
const CXCursor_OMPFlushDirective: CXCursorKind = 246

/** Windows Structured Exception Handling's leave statement.
   */
const CXCursor_SEHLeaveStmt: CXCursorKind = 247

/** OpenMP ordered directive.
   */
const CXCursor_OMPOrderedDirective: CXCursorKind = 248

/** OpenMP atomic directive.
   */
const CXCursor_OMPAtomicDirective: CXCursorKind = 249

/** OpenMP for SIMD directive.
   */
const CXCursor_OMPForSimdDirective: CXCursorKind = 250

/** OpenMP parallel for SIMD directive.
   */
const CXCursor_OMPParallelForSimdDirective: CXCursorKind = 251

/** OpenMP target directive.
   */
const CXCursor_OMPTargetDirective: CXCursorKind = 252

/** OpenMP teams directive.
   */
const CXCursor_OMPTeamsDirective: CXCursorKind = 253

/** OpenMP taskgroup directive.
   */
const CXCursor_OMPTaskgroupDirective: CXCursorKind = 254

/** OpenMP cancellation point directive.
   */
const CXCursor_OMPCancellationPointDirective: CXCursorKind = 255

/** OpenMP cancel directive.
   */
const CXCursor_OMPCancelDirective: CXCursorKind = 256

/** OpenMP target data directive.
   */
const CXCursor_OMPTargetDataDirective: CXCursorKind = 257

/** OpenMP taskloop directive.
   */
const CXCursor_OMPTaskLoopDirective: CXCursorKind = 258

/** OpenMP taskloop simd directive.
   */
const CXCursor_OMPTaskLoopSimdDirective: CXCursorKind = 259

/** OpenMP distribute directive.
   */
const CXCursor_OMPDistributeDirective: CXCursorKind = 260

/** OpenMP target enter data directive.
   */
const CXCursor_OMPTargetEnterDataDirective: CXCursorKind = 261

/** OpenMP target exit data directive.
   */
const CXCursor_OMPTargetExitDataDirective: CXCursorKind = 262

/** OpenMP target parallel directive.
   */
const CXCursor_OMPTargetParallelDirective: CXCursorKind = 263

/** OpenMP target parallel for directive.
   */
const CXCursor_OMPTargetParallelForDirective: CXCursorKind = 264

/** OpenMP target update directive.
   */
const CXCursor_OMPTargetUpdateDirective: CXCursorKind = 265

/** OpenMP distribute parallel for directive.
   */
const CXCursor_OMPDistributeParallelForDirective: CXCursorKind = 266

/** OpenMP distribute parallel for simd directive.
   */
const CXCursor_OMPDistributeParallelForSimdDirective: CXCursorKind = 267

/** OpenMP distribute simd directive.
   */
const CXCursor_OMPDistributeSimdDirective: CXCursorKind = 268

/** OpenMP target parallel for simd directive.
   */
const CXCursor_OMPTargetParallelForSimdDirective: CXCursorKind = 269

/** OpenMP target simd directive.
   */
const CXCursor_OMPTargetSimdDirective: CXCursorKind = 270

/** OpenMP teams distribute directive.
   */
const CXCursor_OMPTeamsDistributeDirective: CXCursorKind = 271

/** OpenMP teams distribute simd directive.
   */
const CXCursor_OMPTeamsDistributeSimdDirective: CXCursorKind = 272

/** OpenMP teams distribute parallel for simd directive.
   */
const CXCursor_OMPTeamsDistributeParallelForSimdDirective: CXCursorKind = 273

/** OpenMP teams distribute parallel for directive.
   */
const CXCursor_OMPTeamsDistributeParallelForDirective: CXCursorKind = 274

/** OpenMP target teams directive.
   */
const CXCursor_OMPTargetTeamsDirective: CXCursorKind = 275

/** OpenMP target teams distribute directive.
   */
const CXCursor_OMPTargetTeamsDistributeDirective: CXCursorKind = 276

/** OpenMP target teams distribute parallel for directive.
   */
const CXCursor_OMPTargetTeamsDistributeParallelForDirective: CXCursorKind = 277

/** OpenMP target teams distribute parallel for simd directive.
   */
const CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective: CXCursorKind = 278

/** OpenMP target teams distribute simd directive.
   */
const CXCursor_OMPTargetTeamsDistributeSimdDirective: CXCursorKind = 279

/** C++2a std::bit_cast expression.
   */
const CXCursor_BuiltinBitCastExpr: CXCursorKind = 280

/** OpenMP master taskloop directive.
   */
const CXCursor_OMPMasterTaskLoopDirective: CXCursorKind = 281

/** OpenMP parallel master taskloop directive.
   */
const CXCursor_OMPParallelMasterTaskLoopDirective: CXCursorKind = 282

/** OpenMP master taskloop simd directive.
   */
const CXCursor_OMPMasterTaskLoopSimdDirective: CXCursorKind = 283

/** OpenMP parallel master taskloop simd directive.
   */
const CXCursor_OMPParallelMasterTaskLoopSimdDirective: CXCursorKind = 284

/** OpenMP parallel master directive.
   */
const CXCursor_OMPParallelMasterDirective: CXCursorKind = 285

/** OpenMP depobj directive.
   */
const CXCursor_OMPDepobjDirective: CXCursorKind = 286

/** OpenMP scan directive.
   */
const CXCursor_OMPScanDirective: CXCursorKind = 287

/** OpenMP tile directive.
   */
const CXCursor_OMPTileDirective: CXCursorKind = 288

/** OpenMP canonical loop.
   */
const CXCursor_OMPCanonicalLoop: CXCursorKind = 289

/** OpenMP interop directive.
   */
const CXCursor_OMPInteropDirective: CXCursorKind = 290

/** OpenMP dispatch directive.
   */
const CXCursor_OMPDispatchDirective: CXCursorKind = 291

/** OpenMP masked directive.
   */
const CXCursor_OMPMaskedDirective: CXCursorKind = 292

/** OpenMP unroll directive.
   */
const CXCursor_OMPUnrollDirective: CXCursorKind = 293

/** OpenMP metadirective directive.
   */
const CXCursor_OMPMetaDirective: CXCursorKind = 294

/** OpenMP loop directive.
   */
const CXCursor_OMPGenericLoopDirective: CXCursorKind = 295

/** OpenMP teams loop directive.
   */
const CXCursor_OMPTeamsGenericLoopDirective: CXCursorKind = 296

/** OpenMP target teams loop directive.
   */
const CXCursor_OMPTargetTeamsGenericLoopDirective: CXCursorKind = 297

/** OpenMP parallel loop directive.
   */
const CXCursor_OMPParallelGenericLoopDirective: CXCursorKind = 298

/** OpenMP target parallel loop directive.
   */
const CXCursor_OMPTargetParallelGenericLoopDirective: CXCursorKind = 299

/** OpenMP parallel masked directive.
   */
const CXCursor_OMPParallelMaskedDirective: CXCursorKind = 300

/** OpenMP masked taskloop directive.
   */
const CXCursor_OMPMaskedTaskLoopDirective: CXCursorKind = 301

/** OpenMP masked taskloop simd directive.
   */
const CXCursor_OMPMaskedTaskLoopSimdDirective: CXCursorKind = 302

/** OpenMP parallel masked taskloop directive.
   */
const CXCursor_OMPParallelMaskedTaskLoopDirective: CXCursorKind = 303

/** OpenMP parallel masked taskloop simd directive.
   */
const CXCursor_OMPParallelMaskedTaskLoopSimdDirective: CXCursorKind = 304

/** OpenMP error directive.
   */
const CXCursor_OMPErrorDirective: CXCursorKind = 305

/** OpenMP scope directive.
   */
const CXCursor_OMPScopeDirective: CXCursorKind = 306

/** OpenMP reverse directive.
   */
const CXCursor_OMPReverseDirective: CXCursorKind = 307

/** OpenMP interchange directive.
   */
const CXCursor_OMPInterchangeDirective: CXCursorKind = 308

/** OpenMP assume directive.
   */
const CXCursor_OMPAssumeDirective: CXCursorKind = 309

/** OpenACC Compute Construct.
   */
const CXCursor_OpenACCComputeConstruct: CXCursorKind = 320

/** OpenACC Loop Construct.
   */
const CXCursor_OpenACCLoopConstruct: CXCursorKind = 321

/** OpenACC Loop Construct.
   */
const CXCursor_LastStmt: CXCursorKind = 321

/**
   * Cursor that represents the translation unit itself.
   *
   * The translation unit cursor exists primarily to act as the root
   * cursor for traversing the contents of a translation unit.
   */
const CXCursor_TranslationUnit: CXCursorKind = 350

/**
   * Cursor that represents the translation unit itself.
   *
   * The translation unit cursor exists primarily to act as the root
   * cursor for traversing the contents of a translation unit.
   */
const CXCursor_FirstAttr: CXCursorKind = 400

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_UnexposedAttr: CXCursorKind = 400

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_IBActionAttr: CXCursorKind = 401

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_IBOutletAttr: CXCursorKind = 402

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_IBOutletCollectionAttr: CXCursorKind = 403

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_CXXFinalAttr: CXCursorKind = 404

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_CXXOverrideAttr: CXCursorKind = 405

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_AnnotateAttr: CXCursorKind = 406

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_AsmLabelAttr: CXCursorKind = 407

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_PackedAttr: CXCursorKind = 408

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_PureAttr: CXCursorKind = 409

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ConstAttr: CXCursorKind = 410

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_NoDuplicateAttr: CXCursorKind = 411

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_CUDAConstantAttr: CXCursorKind = 412

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_CUDADeviceAttr: CXCursorKind = 413

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_CUDAGlobalAttr: CXCursorKind = 414

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_CUDAHostAttr: CXCursorKind = 415

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_CUDASharedAttr: CXCursorKind = 416

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_VisibilityAttr: CXCursorKind = 417

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_DLLExport: CXCursorKind = 418

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_DLLImport: CXCursorKind = 419

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_NSReturnsRetained: CXCursorKind = 420

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_NSReturnsNotRetained: CXCursorKind = 421

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_NSReturnsAutoreleased: CXCursorKind = 422

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_NSConsumesSelf: CXCursorKind = 423

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_NSConsumed: CXCursorKind = 424

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ObjCException: CXCursorKind = 425

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ObjCNSObject: CXCursorKind = 426

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ObjCIndependentClass: CXCursorKind = 427

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ObjCPreciseLifetime: CXCursorKind = 428

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ObjCReturnsInnerPointer: CXCursorKind = 429

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ObjCRequiresSuper: CXCursorKind = 430

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ObjCRootClass: CXCursorKind = 431

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ObjCSubclassingRestricted: CXCursorKind = 432

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ObjCExplicitProtocolImpl: CXCursorKind = 433

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ObjCDesignatedInitializer: CXCursorKind = 434

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ObjCRuntimeVisible: CXCursorKind = 435

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ObjCBoxable: CXCursorKind = 436

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_FlagEnum: CXCursorKind = 437

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_ConvergentAttr: CXCursorKind = 438

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_WarnUnusedAttr: CXCursorKind = 439

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_WarnUnusedResultAttr: CXCursorKind = 440

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_AlignedAttr: CXCursorKind = 441

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_LastAttr: CXCursorKind = 441

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_PreprocessingDirective: CXCursorKind = 500

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_MacroDefinition: CXCursorKind = 501

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_MacroExpansion: CXCursorKind = 502

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_MacroInstantiation: CXCursorKind = 502

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_InclusionDirective: CXCursorKind = 503

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_FirstPreprocessing: CXCursorKind = 500

/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
const CXCursor_LastPreprocessing: CXCursorKind = 503

/**
   * A module import declaration.
   */
const CXCursor_ModuleImportDecl: CXCursorKind = 600

/**
   * A module import declaration.
   */
const CXCursor_TypeAliasTemplateDecl: CXCursorKind = 601

/**
   * A static_assert or _Static_assert node
   */
const CXCursor_StaticAssert: CXCursorKind = 602

/**
   * a friend declaration.
   */
const CXCursor_FriendDecl: CXCursorKind = 603

/**
   * a concept declaration.
   */
const CXCursor_ConceptDecl: CXCursorKind = 604

/**
   * a concept declaration.
   */
const CXCursor_FirstExtraDecl: CXCursorKind = 600

/**
   * a concept declaration.
   */
const CXCursor_LastExtraDecl: CXCursorKind = 604

/**
   * A code completion overload candidate.
   */
const CXCursor_OverloadCandidate: CXCursorKind = 700

/**
 * Retrieve the NULL cursor, which represents no entity.
 */
foreign func clang_getNullCursor(): CXCursor

/**
 * Retrieve the cursor that represents the given translation unit.
 *
 * The translation unit cursor can be used to start traversing the
 * various declarations within the given translation unit.
 */
foreign func clang_getTranslationUnitCursor(arg0: CPointer<CXTranslationUnitImpl>): CXCursor

/**
 * Determine whether two cursors are equivalent.
 */
foreign func clang_equalCursors(arg0: CXCursor, arg1: CXCursor): UInt32

/**
 * Returns non-zero if \p cursor is null.
 */
foreign func clang_Cursor_isNull(cursor: CXCursor): Int32

/**
 * Compute a hash value for the given cursor.
 */
foreign func clang_hashCursor(arg0: CXCursor): UInt32

/**
 * Retrieve the kind of the given cursor.
 */
foreign func clang_getCursorKind(arg0: CXCursor): CXCursorKind

/**
 * Determine whether the given cursor kind represents a declaration.
 */
foreign func clang_isDeclaration(arg0: CXCursorKind): UInt32

/**
 * Determine whether the given declaration is invalid.
 *
 * A declaration is invalid if it could not be parsed successfully.
 *
 * \returns non-zero if the cursor represents a declaration and it is
 * invalid, otherwise NULL.
 */
foreign func clang_isInvalidDeclaration(arg0: CXCursor): UInt32

/**
 * Determine whether the given cursor kind represents a simple
 * reference.
 *
 * Note that other kinds of cursors (such as expressions) can also refer to
 * other cursors. Use clang_getCursorReferenced() to determine whether a
 * particular cursor refers to another entity.
 */
foreign func clang_isReference(arg0: CXCursorKind): UInt32

/**
 * Determine whether the given cursor kind represents an expression.
 */
foreign func clang_isExpression(arg0: CXCursorKind): UInt32

/**
 * Determine whether the given cursor kind represents a statement.
 */
foreign func clang_isStatement(arg0: CXCursorKind): UInt32

/**
 * Determine whether the given cursor kind represents an attribute.
 */
foreign func clang_isAttribute(arg0: CXCursorKind): UInt32

/**
 * Determine whether the given cursor has any attributes.
 */
foreign func clang_Cursor_hasAttrs(C: CXCursor): UInt32

/**
 * Determine whether the given cursor kind represents an invalid
 * cursor.
 */
foreign func clang_isInvalid(arg0: CXCursorKind): UInt32

/**
 * Determine whether the given cursor kind represents a translation
 * unit.
 */
foreign func clang_isTranslationUnit(arg0: CXCursorKind): UInt32

/***
 * Determine whether the given cursor represents a preprocessing
 * element, such as a preprocessor directive or macro instantiation.
 */
foreign func clang_isPreprocessing(arg0: CXCursorKind): UInt32

/***
 * Determine whether the given cursor represents a currently
 *  unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).
 */
foreign func clang_isUnexposed(arg0: CXCursorKind): UInt32

/**
 * Describe the linkage of the entity referred to by a cursor.
 */
type CXLinkageKind = Int32

/** This value indicates that no linkage information is available
   * for a provided CXCursor. */
const CXLinkage_Invalid: CXLinkageKind = 0

/**
   * This is the linkage for variables, parameters, and so on that
   *  have automatic storage.  This covers normal (non-extern) local variables.
   */
const CXLinkage_NoLinkage: CXLinkageKind = 1

/** This is the linkage for static variables and static functions. */
const CXLinkage_Internal: CXLinkageKind = 2

/** This is the linkage for entities with external linkage that live
   * in C++ anonymous namespaces.*/
const CXLinkage_UniqueExternal: CXLinkageKind = 3

/** This is the linkage for entities with true, external linkage. */
const CXLinkage_External: CXLinkageKind = 4

/**
 * Determine the linkage of the entity referred to by a given cursor.
 */
foreign func clang_getCursorLinkage(cursor: CXCursor): CXLinkageKind

type CXVisibilityKind = Int32

/** This value indicates that no visibility information is available
   * for a provided CXCursor. */
const CXVisibility_Invalid: CXVisibilityKind = 0

/** Symbol not seen by the linker. */
const CXVisibility_Hidden: CXVisibilityKind = 1

/** Symbol seen by the linker but resolves to a symbol inside this object. */
const CXVisibility_Protected: CXVisibilityKind = 2

/** Symbol seen by the linker and acts like a normal symbol. */
const CXVisibility_Default: CXVisibilityKind = 3

/**
 * Describe the visibility of the entity referred to by a cursor.
 *
 * This returns the default visibility if not explicitly specified by
 * a visibility attribute. The default visibility may be changed by
 * commandline arguments.
 *
 * \param cursor The cursor to query.
 *
 * \returns The visibility of the cursor.
 */
foreign func clang_getCursorVisibility(cursor: CXCursor): CXVisibilityKind

/**
 * Determine the availability of the entity that this cursor refers to,
 * taking the current target platform into account.
 *
 * \param cursor The cursor to query.
 *
 * \returns The availability of the cursor.
 */
foreign func clang_getCursorAvailability(cursor: CXCursor): CXAvailabilityKind

/**
 * Determine the availability of the entity that this cursor refers to
 * on any platforms for which availability information is known.
 *
 * \param cursor The cursor to query.
 *
 * \param always_deprecated If non-NULL, will be set to indicate whether the
 * entity is deprecated on all platforms.
 *
 * \param deprecated_message If non-NULL, will be set to the message text
 * provided along with the unconditional deprecation of this entity. The client
 * is responsible for deallocating this string.
 *
 * \param always_unavailable If non-NULL, will be set to indicate whether the
 * entity is unavailable on all platforms.
 *
 * \param unavailable_message If non-NULL, will be set to the message text
 * provided along with the unconditional unavailability of this entity. The
 * client is responsible for deallocating this string.
 *
 * \param availability If non-NULL, an array of CXPlatformAvailability instances
 * that will be populated with platform availability information, up to either
 * the number of platforms for which availability information is available (as
 * returned by this function) or \c availability_size, whichever is smaller.
 *
 * \param availability_size The number of elements available in the
 * \c availability array.
 *
 * \returns The number of platforms (N) for which availability information is
 * available (which is unrelated to \c availability_size).
 *
 * Note that the client is responsible for calling
 * \c clang_disposeCXPlatformAvailability to free each of the
 * platform-availability structures returned. There are
 * \c min(N, availability_size) such structures.
 */
foreign func clang_getCursorPlatformAvailability(cursor: CXCursor, always_deprecated: CPointer<Int32>, deprecated_message: CPointer<CXString>, always_unavailable: CPointer<Int32>, unavailable_message: CPointer<CXString>, availability: CPointer<CXPlatformAvailability>, availability_size: Int32): Int32

/**
 * Free the memory associated with a \c CXPlatformAvailability structure.
 */
foreign func clang_disposeCXPlatformAvailability(availability: CPointer<CXPlatformAvailability>): Unit

/**
 * If cursor refers to a variable declaration and it has initializer returns
 * cursor referring to the initializer otherwise return null cursor.
 */
foreign func clang_Cursor_getVarDeclInitializer(cursor: CXCursor): CXCursor

/**
 * If cursor refers to a variable declaration that has global storage returns 1.
 * If cursor refers to a variable declaration that doesn't have global storage
 * returns 0. Otherwise returns -1.
 */
foreign func clang_Cursor_hasVarDeclGlobalStorage(cursor: CXCursor): Int32

/**
 * If cursor refers to a variable declaration that has external storage
 * returns 1. If cursor refers to a variable declaration that doesn't have
 * external storage returns 0. Otherwise returns -1.
 */
foreign func clang_Cursor_hasVarDeclExternalStorage(cursor: CXCursor): Int32

/**
 * Describe the "language" of the entity referred to by a cursor.
 */
type CXLanguageKind = Int32

const CXLanguage_Invalid: CXLanguageKind = 0

const CXLanguage_C: CXLanguageKind = 1

const CXLanguage_ObjC: CXLanguageKind = 2

const CXLanguage_CPlusPlus: CXLanguageKind = 3

/**
 * Determine the "language" of the entity referred to by a given cursor.
 */
foreign func clang_getCursorLanguage(cursor: CXCursor): CXLanguageKind

/**
 * Describe the "thread-local storage (TLS) kind" of the declaration
 * referred to by a cursor.
 */
type CXTLSKind = Int32

const CXTLS_None: CXTLSKind = 0

const CXTLS_Dynamic: CXTLSKind = 1

const CXTLS_Static: CXTLSKind = 2

/**
 * Determine the "thread-local storage (TLS) kind" of the declaration
 * referred to by a cursor.
 */
foreign func clang_getCursorTLSKind(cursor: CXCursor): CXTLSKind

/**
 * Returns the translation unit that a cursor originated from.
 */
foreign func clang_Cursor_getTranslationUnit(arg0: CXCursor): CPointer<CXTranslationUnitImpl>

/**
 * Creates an empty CXCursorSet.
 */
foreign func clang_createCXCursorSet(): CPointer<CXCursorSetImpl>

/**
 * Disposes a CXCursorSet and releases its associated memory.
 */
foreign func clang_disposeCXCursorSet(cset: CPointer<CXCursorSetImpl>): Unit

/**
 * Queries a CXCursorSet to see if it contains a specific CXCursor.
 *
 * \returns non-zero if the set contains the specified cursor.
 */
foreign func clang_CXCursorSet_contains(cset: CPointer<CXCursorSetImpl>, cursor: CXCursor): UInt32

/**
 * Inserts a CXCursor into a CXCursorSet.
 *
 * \returns zero if the CXCursor was already in the set, and non-zero otherwise.
 */
foreign func clang_CXCursorSet_insert(cset: CPointer<CXCursorSetImpl>, cursor: CXCursor): UInt32

/**
 * Determine the semantic parent of the given cursor.
 *
 * The semantic parent of a cursor is the cursor that semantically contains
 * the given \p cursor. For many declarations, the lexical and semantic parents
 * are equivalent (the lexical parent is returned by
 * \c clang_getCursorLexicalParent()). They diverge when declarations or
 * definitions are provided out-of-line. For example:
 *
 * \code
 * class C {
 *  void f();
 * };
 *
 * void C::f() { }
 * \endcode
 *
 * In the out-of-line definition of \c C::f, the semantic parent is
 * the class \c C, of which this function is a member. The lexical parent is
 * the place where the declaration actually occurs in the source code; in this
 * case, the definition occurs in the translation unit. In general, the
 * lexical parent for a given entity can change without affecting the semantics
 * of the program, and the lexical parent of different declarations of the
 * same entity may be different. Changing the semantic parent of a declaration,
 * on the other hand, can have a major impact on semantics, and redeclarations
 * of a particular entity should all have the same semantic context.
 *
 * In the example above, both declarations of \c C::f have \c C as their
 * semantic context, while the lexical context of the first \c C::f is \c C
 * and the lexical context of the second \c C::f is the translation unit.
 *
 * For global declarations, the semantic parent is the translation unit.
 */
foreign func clang_getCursorSemanticParent(cursor: CXCursor): CXCursor

/**
 * Determine the lexical parent of the given cursor.
 *
 * The lexical parent of a cursor is the cursor in which the given \p cursor
 * was actually written. For many declarations, the lexical and semantic parents
 * are equivalent (the semantic parent is returned by
 * \c clang_getCursorSemanticParent()). They diverge when declarations or
 * definitions are provided out-of-line. For example:
 *
 * \code
 * class C {
 *  void f();
 * };
 *
 * void C::f() { }
 * \endcode
 *
 * In the out-of-line definition of \c C::f, the semantic parent is
 * the class \c C, of which this function is a member. The lexical parent is
 * the place where the declaration actually occurs in the source code; in this
 * case, the definition occurs in the translation unit. In general, the
 * lexical parent for a given entity can change without affecting the semantics
 * of the program, and the lexical parent of different declarations of the
 * same entity may be different. Changing the semantic parent of a declaration,
 * on the other hand, can have a major impact on semantics, and redeclarations
 * of a particular entity should all have the same semantic context.
 *
 * In the example above, both declarations of \c C::f have \c C as their
 * semantic context, while the lexical context of the first \c C::f is \c C
 * and the lexical context of the second \c C::f is the translation unit.
 *
 * For declarations written in the global scope, the lexical parent is
 * the translation unit.
 */
foreign func clang_getCursorLexicalParent(cursor: CXCursor): CXCursor

/**
 * Determine the set of methods that are overridden by the given
 * method.
 *
 * In both Objective-C and C++, a method (aka virtual member function,
 * in C++) can override a virtual method in a base class. For
 * Objective-C, a method is said to override any method in the class's
 * base class, its protocols, or its categories' protocols, that has the same
 * selector and is of the same kind (class or instance).
 * If no such method exists, the search continues to the class's superclass,
 * its protocols, and its categories, and so on. A method from an Objective-C
 * implementation is considered to override the same methods as its
 * corresponding method in the interface.
 *
 * For C++, a virtual member function overrides any virtual member
 * function with the same signature that occurs in its base
 * classes. With multiple inheritance, a virtual member function can
 * override several virtual member functions coming from different
 * base classes.
 *
 * In all cases, this function determines the immediate overridden
 * method, rather than all of the overridden methods. For example, if
 * a method is originally declared in a class A, then overridden in B
 * (which in inherits from A) and also in C (which inherited from B),
 * then the only overridden method returned from this function when
 * invoked on C's method will be B's method. The client may then
 * invoke this function again, given the previously-found overridden
 * methods, to map out the complete method-override set.
 *
 * \param cursor A cursor representing an Objective-C or C++
 * method. This routine will compute the set of methods that this
 * method overrides.
 *
 * \param overridden A pointer whose pointee will be replaced with a
 * pointer to an array of cursors, representing the set of overridden
 * methods. If there are no overridden methods, the pointee will be
 * set to NULL. The pointee must be freed via a call to
 * \c clang_disposeOverriddenCursors().
 *
 * \param num_overridden A pointer to the number of overridden
 * functions, will be set to the number of overridden functions in the
 * array pointed to by \p overridden.
 */
foreign func clang_getOverriddenCursors(cursor: CXCursor, overridden: CPointer<CPointer<CXCursor>>, num_overridden: CPointer<UInt32>): Unit

/**
 * Free the set of overridden cursors returned by \c
 * clang_getOverriddenCursors().
 */
foreign func clang_disposeOverriddenCursors(overridden: CPointer<CXCursor>): Unit

/**
 * Retrieve the file that is included by the given inclusion directive
 * cursor.
 */
foreign func clang_getIncludedFile(cursor: CXCursor): CPointer<Unit>

/**
 * Map a source location to the cursor that describes the entity at that
 * location in the source code.
 *
 * clang_getCursor() maps an arbitrary source location within a translation
 * unit down to the most specific cursor that describes the entity at that
 * location. For example, given an expression \c x + y, invoking
 * clang_getCursor() with a source location pointing to "x" will return the
 * cursor for "x"; similarly for "y". If the cursor points anywhere between
 * "x" or "y" (e.g., on the + or the whitespace around it), clang_getCursor()
 * will return a cursor referring to the "+" expression.
 *
 * \returns a cursor representing the entity at the given source location, or
 * a NULL cursor if no such entity can be found.
 */
foreign func clang_getCursor(arg0: CPointer<CXTranslationUnitImpl>, arg1: CXSourceLocation): CXCursor

/**
 * Retrieve the physical location of the source constructor referenced
 * by the given cursor.
 *
 * The location of a declaration is typically the location of the name of that
 * declaration, where the name of that declaration would occur if it is
 * unnamed, or some keyword that introduces that particular declaration.
 * The location of a reference is where that reference occurs within the
 * source code.
 */
foreign func clang_getCursorLocation(arg0: CXCursor): CXSourceLocation

/**
 * Retrieve the physical extent of the source construct referenced by
 * the given cursor.
 *
 * The extent of a cursor starts with the file/line/column pointing at the
 * first character within the source construct that the cursor refers to and
 * ends with the last character within that source construct. For a
 * declaration, the extent covers the declaration itself. For a reference,
 * the extent covers the location of the reference (e.g., where the referenced
 * entity was actually used).
 */
foreign func clang_getCursorExtent(arg0: CXCursor): CXSourceRange

/**
 * Describes the kind of type
 */
type CXTypeKind = Int32

/**
   * Represents an invalid type (e.g., where no type is available).
   */
const CXType_Invalid: CXTypeKind = 0

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Unexposed: CXTypeKind = 1

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Void: CXTypeKind = 2

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Bool: CXTypeKind = 3

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Char_U: CXTypeKind = 4

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_UChar: CXTypeKind = 5

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Char16: CXTypeKind = 6

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Char32: CXTypeKind = 7

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_UShort: CXTypeKind = 8

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_UInt: CXTypeKind = 9

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_ULong: CXTypeKind = 10

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_ULongLong: CXTypeKind = 11

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_UInt128: CXTypeKind = 12

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Char_S: CXTypeKind = 13

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_SChar: CXTypeKind = 14

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_WChar: CXTypeKind = 15

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Short: CXTypeKind = 16

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Int: CXTypeKind = 17

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Long: CXTypeKind = 18

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_LongLong: CXTypeKind = 19

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Int128: CXTypeKind = 20

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Float: CXTypeKind = 21

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Double: CXTypeKind = 22

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_LongDouble: CXTypeKind = 23

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_NullPtr: CXTypeKind = 24

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Overload: CXTypeKind = 25

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Dependent: CXTypeKind = 26

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_ObjCId: CXTypeKind = 27

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_ObjCClass: CXTypeKind = 28

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_ObjCSel: CXTypeKind = 29

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Float128: CXTypeKind = 30

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Half: CXTypeKind = 31

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Float16: CXTypeKind = 32

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_ShortAccum: CXTypeKind = 33

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Accum: CXTypeKind = 34

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_LongAccum: CXTypeKind = 35

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_UShortAccum: CXTypeKind = 36

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_UAccum: CXTypeKind = 37

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_ULongAccum: CXTypeKind = 38

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_BFloat16: CXTypeKind = 39

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Ibm128: CXTypeKind = 40

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_FirstBuiltin: CXTypeKind = 2

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_LastBuiltin: CXTypeKind = 40

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Complex: CXTypeKind = 100

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Pointer: CXTypeKind = 101

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_BlockPointer: CXTypeKind = 102

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_LValueReference: CXTypeKind = 103

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_RValueReference: CXTypeKind = 104

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Record: CXTypeKind = 105

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Enum: CXTypeKind = 106

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Typedef: CXTypeKind = 107

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_ObjCInterface: CXTypeKind = 108

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_ObjCObjectPointer: CXTypeKind = 109

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_FunctionNoProto: CXTypeKind = 110

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_FunctionProto: CXTypeKind = 111

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_ConstantArray: CXTypeKind = 112

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Vector: CXTypeKind = 113

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_IncompleteArray: CXTypeKind = 114

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_VariableArray: CXTypeKind = 115

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_DependentSizedArray: CXTypeKind = 116

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_MemberPointer: CXTypeKind = 117

/**
   * A type whose specific kind is not exposed via this
   * interface.
   */
const CXType_Auto: CXTypeKind = 118

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_Elaborated: CXTypeKind = 119

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_Pipe: CXTypeKind = 120

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage1dRO: CXTypeKind = 121

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage1dArrayRO: CXTypeKind = 122

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage1dBufferRO: CXTypeKind = 123

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dRO: CXTypeKind = 124

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dArrayRO: CXTypeKind = 125

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dDepthRO: CXTypeKind = 126

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dArrayDepthRO: CXTypeKind = 127

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dMSAARO: CXTypeKind = 128

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dArrayMSAARO: CXTypeKind = 129

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dMSAADepthRO: CXTypeKind = 130

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dArrayMSAADepthRO: CXTypeKind = 131

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage3dRO: CXTypeKind = 132

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage1dWO: CXTypeKind = 133

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage1dArrayWO: CXTypeKind = 134

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage1dBufferWO: CXTypeKind = 135

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dWO: CXTypeKind = 136

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dArrayWO: CXTypeKind = 137

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dDepthWO: CXTypeKind = 138

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dArrayDepthWO: CXTypeKind = 139

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dMSAAWO: CXTypeKind = 140

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dArrayMSAAWO: CXTypeKind = 141

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dMSAADepthWO: CXTypeKind = 142

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dArrayMSAADepthWO: CXTypeKind = 143

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage3dWO: CXTypeKind = 144

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage1dRW: CXTypeKind = 145

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage1dArrayRW: CXTypeKind = 146

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage1dBufferRW: CXTypeKind = 147

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dRW: CXTypeKind = 148

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dArrayRW: CXTypeKind = 149

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dDepthRW: CXTypeKind = 150

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dArrayDepthRW: CXTypeKind = 151

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dMSAARW: CXTypeKind = 152

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dArrayMSAARW: CXTypeKind = 153

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dMSAADepthRW: CXTypeKind = 154

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage2dArrayMSAADepthRW: CXTypeKind = 155

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLImage3dRW: CXTypeKind = 156

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLSampler: CXTypeKind = 157

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLEvent: CXTypeKind = 158

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLQueue: CXTypeKind = 159

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLReserveID: CXTypeKind = 160

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_ObjCObject: CXTypeKind = 161

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_ObjCTypeParam: CXTypeKind = 162

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_Attributed: CXTypeKind = 163

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCMcePayload: CXTypeKind = 164

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCImePayload: CXTypeKind = 165

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCRefPayload: CXTypeKind = 166

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCSicPayload: CXTypeKind = 167

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCMceResult: CXTypeKind = 168

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCImeResult: CXTypeKind = 169

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCRefResult: CXTypeKind = 170

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCSicResult: CXTypeKind = 171

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCImeResultSingleReferenceStreamout: CXTypeKind = 172

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCImeResultDualReferenceStreamout: CXTypeKind = 173

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCImeSingleReferenceStreamin: CXTypeKind = 174

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCImeDualReferenceStreamin: CXTypeKind = 175

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout: CXTypeKind = 172

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout: CXTypeKind = 173

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCImeSingleRefStreamin: CXTypeKind = 174

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_OCLIntelSubgroupAVCImeDualRefStreamin: CXTypeKind = 175

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_ExtVector: CXTypeKind = 176

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_Atomic: CXTypeKind = 177

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_BTFTagAttributed: CXTypeKind = 178

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_HLSLResource: CXTypeKind = 179

/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
const CXType_HLSLAttributedResource: CXTypeKind = 180

/**
 * Describes the calling convention of a function type
 */
type CXCallingConv = Int32

const CXCallingConv_Default: CXCallingConv = 0

const CXCallingConv_C: CXCallingConv = 1

const CXCallingConv_X86StdCall: CXCallingConv = 2

const CXCallingConv_X86FastCall: CXCallingConv = 3

const CXCallingConv_X86ThisCall: CXCallingConv = 4

const CXCallingConv_X86Pascal: CXCallingConv = 5

const CXCallingConv_AAPCS: CXCallingConv = 6

const CXCallingConv_AAPCS_VFP: CXCallingConv = 7

const CXCallingConv_X86RegCall: CXCallingConv = 8

const CXCallingConv_IntelOclBicc: CXCallingConv = 9

const CXCallingConv_Win64: CXCallingConv = 10

const CXCallingConv_X86_64Win64: CXCallingConv = 10

const CXCallingConv_X86_64SysV: CXCallingConv = 11

const CXCallingConv_X86VectorCall: CXCallingConv = 12

const CXCallingConv_Swift: CXCallingConv = 13

const CXCallingConv_PreserveMost: CXCallingConv = 14

const CXCallingConv_PreserveAll: CXCallingConv = 15

const CXCallingConv_AArch64VectorCall: CXCallingConv = 16

const CXCallingConv_SwiftAsync: CXCallingConv = 17

const CXCallingConv_AArch64SVEPCS: CXCallingConv = 18

const CXCallingConv_M68kRTD: CXCallingConv = 19

const CXCallingConv_PreserveNone: CXCallingConv = 20

const CXCallingConv_RISCVVectorCall: CXCallingConv = 21

const CXCallingConv_Invalid: CXCallingConv = 100

const CXCallingConv_Unexposed: CXCallingConv = 200

/**
 * Retrieve the type of a CXCursor (if any).
 */
foreign func clang_getCursorType(C: CXCursor): CXType

/**
 * Pretty-print the underlying type using the rules of the
 * language of the translation unit from which it came.
 *
 * If the type is invalid, an empty string is returned.
 */
foreign func clang_getTypeSpelling(CT: CXType): CXString

/**
 * Retrieve the underlying type of a typedef declaration.
 *
 * If the cursor does not reference a typedef declaration, an invalid type is
 * returned.
 */
foreign func clang_getTypedefDeclUnderlyingType(C: CXCursor): CXType

/**
 * Retrieve the integer type of an enum declaration.
 *
 * If the cursor does not reference an enum declaration, an invalid type is
 * returned.
 */
foreign func clang_getEnumDeclIntegerType(C: CXCursor): CXType

/**
 * Retrieve the integer value of an enum constant declaration as a signed
 *  long long.
 *
 * If the cursor does not reference an enum constant declaration, LLONG_MIN is
 * returned. Since this is also potentially a valid constant value, the kind of
 * the cursor must be verified before calling this function.
 */
foreign func clang_getEnumConstantDeclValue(C: CXCursor): Int64

/**
 * Retrieve the integer value of an enum constant declaration as an unsigned
 *  long long.
 *
 * If the cursor does not reference an enum constant declaration, ULLONG_MAX is
 * returned. Since this is also potentially a valid constant value, the kind of
 * the cursor must be verified before calling this function.
 */
foreign func clang_getEnumConstantDeclUnsignedValue(C: CXCursor): UInt64

/**
 * Returns non-zero if the cursor specifies a Record member that is a bit-field.
 */
foreign func clang_Cursor_isBitField(C: CXCursor): UInt32

/**
 * Retrieve the bit width of a bit-field declaration as an integer.
 *
 * If the cursor does not reference a bit-field, or if the bit-field's width
 * expression cannot be evaluated, -1 is returned.
 *
 * For example:
 * \code
 * if (clang_Cursor_isBitField(Cursor)) {
 *   int Width = clang_getFieldDeclBitWidth(Cursor);
 *   if (Width != -1) {
 *     // The bit-field width is not value-dependent.
 *   }
 * }
 * \endcode
 */
foreign func clang_getFieldDeclBitWidth(C: CXCursor): Int32

/**
 * Retrieve the number of non-variadic arguments associated with a given
 * cursor.
 *
 * The number of arguments can be determined for calls as well as for
 * declarations of functions or methods. For other cursors -1 is returned.
 */
foreign func clang_Cursor_getNumArguments(C: CXCursor): Int32

/**
 * Retrieve the argument cursor of a function or method.
 *
 * The argument cursor can be determined for calls as well as for declarations
 * of functions or methods. For other cursors and for invalid indices, an
 * invalid cursor is returned.
 */
foreign func clang_Cursor_getArgument(C: CXCursor, i: UInt32): CXCursor

/**
 * Describes the kind of a template argument.
 *
 * See the definition of llvm::clang::TemplateArgument::ArgKind for full
 * element descriptions.
 */
type CXTemplateArgumentKind = Int32

const CXTemplateArgumentKind_Null: CXTemplateArgumentKind = 0

const CXTemplateArgumentKind_Type: CXTemplateArgumentKind = 1

const CXTemplateArgumentKind_Declaration: CXTemplateArgumentKind = 2

const CXTemplateArgumentKind_NullPtr: CXTemplateArgumentKind = 3

const CXTemplateArgumentKind_Integral: CXTemplateArgumentKind = 4

const CXTemplateArgumentKind_Template: CXTemplateArgumentKind = 5

const CXTemplateArgumentKind_TemplateExpansion: CXTemplateArgumentKind = 6

const CXTemplateArgumentKind_Expression: CXTemplateArgumentKind = 7

const CXTemplateArgumentKind_Pack: CXTemplateArgumentKind = 8

const CXTemplateArgumentKind_Invalid: CXTemplateArgumentKind = 9

/**
 * Returns the number of template args of a function, struct, or class decl
 * representing a template specialization.
 *
 * If the argument cursor cannot be converted into a template function
 * declaration, -1 is returned.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, -7, true>();
 *
 * The value 3 would be returned from this call.
 */
foreign func clang_Cursor_getNumTemplateArguments(C: CXCursor): Int32

/**
 * Retrieve the kind of the I'th template argument of the CXCursor C.
 *
 * If the argument CXCursor does not represent a FunctionDecl, StructDecl, or
 * ClassTemplatePartialSpecialization, an invalid template argument kind is
 * returned.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, -7, true>();
 *
 * For I = 0, 1, and 2, Type, Integral, and Integral will be returned,
 * respectively.
 */
foreign func clang_Cursor_getTemplateArgumentKind(C: CXCursor, I: UInt32): CXTemplateArgumentKind

/**
 * Retrieve a CXType representing the type of a TemplateArgument of a
 *  function decl representing a template specialization.
 *
 * If the argument CXCursor does not represent a FunctionDecl, StructDecl,
 * ClassDecl or ClassTemplatePartialSpecialization whose I'th template argument
 * has a kind of CXTemplateArgKind_Integral, an invalid type is returned.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, -7, true>();
 *
 * If called with I = 0, "float", will be returned.
 * Invalid types will be returned for I == 1 or 2.
 */
foreign func clang_Cursor_getTemplateArgumentType(C: CXCursor, I: UInt32): CXType

/**
 * Retrieve the value of an Integral TemplateArgument (of a function
 *  decl representing a template specialization) as a signed long long.
 *
 * It is undefined to call this function on a CXCursor that does not represent a
 * FunctionDecl, StructDecl, ClassDecl or ClassTemplatePartialSpecialization
 * whose I'th template argument is not an integral value.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, -7, true>();
 *
 * If called with I = 1 or 2, -7 or true will be returned, respectively.
 * For I == 0, this function's behavior is undefined.
 */
foreign func clang_Cursor_getTemplateArgumentValue(C: CXCursor, I: UInt32): Int64

/**
 * Retrieve the value of an Integral TemplateArgument (of a function
 *  decl representing a template specialization) as an unsigned long long.
 *
 * It is undefined to call this function on a CXCursor that does not represent a
 * FunctionDecl, StructDecl, ClassDecl or ClassTemplatePartialSpecialization or
 * whose I'th template argument is not an integral value.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, 2147483649, true>();
 *
 * If called with I = 1 or 2, 2147483649 or true will be returned, respectively.
 * For I == 0, this function's behavior is undefined.
 */
foreign func clang_Cursor_getTemplateArgumentUnsignedValue(C: CXCursor, I: UInt32): UInt64

/**
 * Determine whether two CXTypes represent the same type.
 *
 * \returns non-zero if the CXTypes represent the same type and
 *          zero otherwise.
 */
foreign func clang_equalTypes(A: CXType, B: CXType): UInt32

/**
 * Return the canonical type for a CXType.
 *
 * Clang's type system explicitly models typedefs and all the ways
 * a specific type can be represented.  The canonical type is the underlying
 * type with all the "sugar" removed.  For example, if 'T' is a typedef
 * for 'int', the canonical type for 'T' would be 'int'.
 */
foreign func clang_getCanonicalType(T: CXType): CXType

/**
 * Determine whether a CXType has the "const" qualifier set,
 * without looking through typedefs that may have added "const" at a
 * different level.
 */
foreign func clang_isConstQualifiedType(T: CXType): UInt32

/**
 * Determine whether a  CXCursor that is a macro, is
 * function like.
 */
foreign func clang_Cursor_isMacroFunctionLike(C: CXCursor): UInt32

/**
 * Determine whether a  CXCursor that is a macro, is a
 * builtin one.
 */
foreign func clang_Cursor_isMacroBuiltin(C: CXCursor): UInt32

/**
 * Determine whether a  CXCursor that is a function declaration, is an
 * inline declaration.
 */
foreign func clang_Cursor_isFunctionInlined(C: CXCursor): UInt32

/**
 * Determine whether a CXType has the "volatile" qualifier set,
 * without looking through typedefs that may have added "volatile" at
 * a different level.
 */
foreign func clang_isVolatileQualifiedType(T: CXType): UInt32

/**
 * Determine whether a CXType has the "restrict" qualifier set,
 * without looking through typedefs that may have added "restrict" at a
 * different level.
 */
foreign func clang_isRestrictQualifiedType(T: CXType): UInt32

/**
 * Returns the address space of the given type.
 */
foreign func clang_getAddressSpace(T: CXType): UInt32

/**
 * Returns the typedef name of the given type.
 */
foreign func clang_getTypedefName(CT: CXType): CXString

/**
 * For pointer types, returns the type of the pointee.
 */
foreign func clang_getPointeeType(T: CXType): CXType

/**
 * Retrieve the unqualified variant of the given type, removing as
 * little sugar as possible.
 *
 * For example, given the following series of typedefs:
 *
 * \code
 * typedef int Integer;
 * typedef const Integer CInteger;
 * typedef CInteger DifferenceType;
 * \endcode
 *
 * Executing \c clang_getUnqualifiedType() on a \c CXType that
 * represents \c DifferenceType, will desugar to a type representing
 * \c Integer, that has no qualifiers.
 *
 * And, executing \c clang_getUnqualifiedType() on the type of the
 * first argument of the following function declaration:
 *
 * \code
 * void foo(const int);
 * \endcode
 *
 * Will return a type representing \c int, removing the \c const
 * qualifier.
 *
 * Sugar over array types is not desugared.
 *
 * A type can be checked for qualifiers with \c
 * clang_isConstQualifiedType(), \c clang_isVolatileQualifiedType()
 * and \c clang_isRestrictQualifiedType().
 *
 * A type that resulted from a call to \c clang_getUnqualifiedType
 * will return \c false for all of the above calls.
 */
foreign func clang_getUnqualifiedType(CT: CXType): CXType

/**
 * For reference types (e.g., "const int&"), returns the type that the
 * reference refers to (e.g "const int").
 *
 * Otherwise, returns the type itself.
 *
 * A type that has kind \c CXType_LValueReference or
 * \c CXType_RValueReference is a reference type.
 */
foreign func clang_getNonReferenceType(CT: CXType): CXType

/**
 * Return the cursor for the declaration of the given type.
 */
foreign func clang_getTypeDeclaration(T: CXType): CXCursor

/**
 * Returns the Objective-C type encoding for the specified declaration.
 */
foreign func clang_getDeclObjCTypeEncoding(C: CXCursor): CXString

/**
 * Returns the Objective-C type encoding for the specified CXType.
 */
foreign func clang_Type_getObjCEncoding(type_: CXType): CXString

/**
 * Retrieve the spelling of a given CXTypeKind.
 */
foreign func clang_getTypeKindSpelling(K: CXTypeKind): CXString

/**
 * Retrieve the calling convention associated with a function type.
 *
 * If a non-function type is passed in, CXCallingConv_Invalid is returned.
 */
foreign func clang_getFunctionTypeCallingConv(T: CXType): CXCallingConv

/**
 * Retrieve the return type associated with a function type.
 *
 * If a non-function type is passed in, an invalid type is returned.
 */
foreign func clang_getResultType(T: CXType): CXType

/**
 * Retrieve the exception specification type associated with a function type.
 * This is a value of type CXCursor_ExceptionSpecificationKind.
 *
 * If a non-function type is passed in, an error code of -1 is returned.
 */
foreign func clang_getExceptionSpecificationType(T: CXType): Int32

/**
 * Retrieve the number of non-variadic parameters associated with a
 * function type.
 *
 * If a non-function type is passed in, -1 is returned.
 */
foreign func clang_getNumArgTypes(T: CXType): Int32

/**
 * Retrieve the type of a parameter of a function type.
 *
 * If a non-function type is passed in or the function does not have enough
 * parameters, an invalid type is returned.
 */
foreign func clang_getArgType(T: CXType, i: UInt32): CXType

/**
 * Retrieves the base type of the ObjCObjectType.
 *
 * If the type is not an ObjC object, an invalid type is returned.
 */
foreign func clang_Type_getObjCObjectBaseType(T: CXType): CXType

/**
 * Retrieve the number of protocol references associated with an ObjC object/id.
 *
 * If the type is not an ObjC object, 0 is returned.
 */
foreign func clang_Type_getNumObjCProtocolRefs(T: CXType): UInt32

/**
 * Retrieve the decl for a protocol reference for an ObjC object/id.
 *
 * If the type is not an ObjC object or there are not enough protocol
 * references, an invalid cursor is returned.
 */
foreign func clang_Type_getObjCProtocolDecl(T: CXType, i: UInt32): CXCursor

/**
 * Retrieve the number of type arguments associated with an ObjC object.
 *
 * If the type is not an ObjC object, 0 is returned.
 */
foreign func clang_Type_getNumObjCTypeArgs(T: CXType): UInt32

/**
 * Retrieve a type argument associated with an ObjC object.
 *
 * If the type is not an ObjC or the index is not valid,
 * an invalid type is returned.
 */
foreign func clang_Type_getObjCTypeArg(T: CXType, i: UInt32): CXType

/**
 * Return 1 if the CXType is a variadic function type, and 0 otherwise.
 */
foreign func clang_isFunctionTypeVariadic(T: CXType): UInt32

/**
 * Retrieve the return type associated with a given cursor.
 *
 * This only returns a valid type if the cursor refers to a function or method.
 */
foreign func clang_getCursorResultType(C: CXCursor): CXType

/**
 * Retrieve the exception specification type associated with a given cursor.
 * This is a value of type CXCursor_ExceptionSpecificationKind.
 *
 * This only returns a valid result if the cursor refers to a function or
 * method.
 */
foreign func clang_getCursorExceptionSpecificationType(C: CXCursor): Int32

/**
 * Return 1 if the CXType is a POD (plain old data) type, and 0
 *  otherwise.
 */
foreign func clang_isPODType(T: CXType): UInt32

/**
 * Return the element type of an array, complex, or vector type.
 *
 * If a type is passed in that is not an array, complex, or vector type,
 * an invalid type is returned.
 */
foreign func clang_getElementType(T: CXType): CXType

/**
 * Return the number of elements of an array or vector type.
 *
 * If a type is passed in that is not an array or vector type,
 * -1 is returned.
 */
foreign func clang_getNumElements(T: CXType): Int64

/**
 * Return the element type of an array type.
 *
 * If a non-array type is passed in, an invalid type is returned.
 */
foreign func clang_getArrayElementType(T: CXType): CXType

/**
 * Return the array size of a constant array.
 *
 * If a non-array type is passed in, -1 is returned.
 */
foreign func clang_getArraySize(T: CXType): Int64

/**
 * Retrieve the type named by the qualified-id.
 *
 * If a non-elaborated type is passed in, an invalid type is returned.
 */
foreign func clang_Type_getNamedType(T: CXType): CXType

/**
 * Determine if a typedef is 'transparent' tag.
 *
 * A typedef is considered 'transparent' if it shares a name and spelling
 * location with its underlying tag type, as is the case with the NS_ENUM macro.
 *
 * \returns non-zero if transparent and zero otherwise.
 */
foreign func clang_Type_isTransparentTagTypedef(T: CXType): UInt32

type CXTypeNullabilityKind = Int32

/**
   * Values of this type can never be null.
   */
const CXTypeNullability_NonNull: CXTypeNullabilityKind = 0

/**
   * Values of this type can be null.
   */
const CXTypeNullability_Nullable: CXTypeNullabilityKind = 1

/**
   * Whether values of this type can be null is (explicitly)
   * unspecified. This captures a (fairly rare) case where we
   * can't conclude anything about the nullability of the type even
   * though it has been considered.
   */
const CXTypeNullability_Unspecified: CXTypeNullabilityKind = 2

/**
   * Nullability is not applicable to this type.
   */
const CXTypeNullability_Invalid: CXTypeNullabilityKind = 3

/**
   * Generally behaves like Nullable, except when used in a block parameter that
   * was imported into a swift async method. There, swift will assume that the
   * parameter can get null even if no error occurred. _Nullable parameters are
   * assumed to only get null on error.
   */
const CXTypeNullability_NullableResult: CXTypeNullabilityKind = 4

/**
 * Retrieve the nullability kind of a pointer type.
 */
foreign func clang_Type_getNullability(T: CXType): CXTypeNullabilityKind

/**
 * List the possible error codes for \c clang_Type_getSizeOf,
 *   \c clang_Type_getAlignOf, \c clang_Type_getOffsetOf and
 *   \c clang_Cursor_getOffsetOf.
 *
 * A value of this enumeration type can be returned if the target type is not
 * a valid argument to sizeof, alignof or offsetof.
 */
type CXTypeLayoutError = Int32

/**
   * Type is of kind CXType_Invalid.
   */
const CXTypeLayoutError_Invalid: CXTypeLayoutError = -1

/**
   * The type is an incomplete Type.
   */
const CXTypeLayoutError_Incomplete: CXTypeLayoutError = -2

/**
   * The type is a dependent Type.
   */
const CXTypeLayoutError_Dependent: CXTypeLayoutError = -3

/**
   * The type is not a constant size type.
   */
const CXTypeLayoutError_NotConstantSize: CXTypeLayoutError = -4

/**
   * The Field name is not valid for this record.
   */
const CXTypeLayoutError_InvalidFieldName: CXTypeLayoutError = -5

/**
   * The type is undeduced.
   */
const CXTypeLayoutError_Undeduced: CXTypeLayoutError = -6

/**
 * Return the alignment of a type in bytes as per C++[expr.alignof]
 *   standard.
 *
 * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.
 * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete
 *   is returned.
 * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is
 *   returned.
 * If the type declaration is not a constant size type,
 *   CXTypeLayoutError_NotConstantSize is returned.
 */
foreign func clang_Type_getAlignOf(T: CXType): Int64

/**
 * Return the class type of an member pointer type.
 *
 * If a non-member-pointer type is passed in, an invalid type is returned.
 */
foreign func clang_Type_getClassType(T: CXType): CXType

/**
 * Return the size of a type in bytes as per C++[expr.sizeof] standard.
 *
 * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.
 * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete
 *   is returned.
 * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is
 *   returned.
 */
foreign func clang_Type_getSizeOf(T: CXType): Int64

/**
 * Return the offset of a field named S in a record of type T in bits
 *   as it would be returned by __offsetof__ as per C++11[18.2p4]
 *
 * If the cursor is not a record field declaration, CXTypeLayoutError_Invalid
 *   is returned.
 * If the field's type declaration is an incomplete type,
 *   CXTypeLayoutError_Incomplete is returned.
 * If the field's type declaration is a dependent type,
 *   CXTypeLayoutError_Dependent is returned.
 * If the field's name S is not found,
 *   CXTypeLayoutError_InvalidFieldName is returned.
 */
foreign func clang_Type_getOffsetOf(T: CXType, S: CString): Int64

/**
 * Return the type that was modified by this attributed type.
 *
 * If the type is not an attributed type, an invalid type is returned.
 */
foreign func clang_Type_getModifiedType(T: CXType): CXType

/**
 * Gets the type contained by this atomic type.
 *
 * If a non-atomic type is passed in, an invalid type is returned.
 */
foreign func clang_Type_getValueType(CT: CXType): CXType

/**
 * Return the offset of the field represented by the Cursor.
 *
 * If the cursor is not a field declaration, -1 is returned.
 * If the cursor semantic parent is not a record field declaration,
 *   CXTypeLayoutError_Invalid is returned.
 * If the field's type declaration is an incomplete type,
 *   CXTypeLayoutError_Incomplete is returned.
 * If the field's type declaration is a dependent type,
 *   CXTypeLayoutError_Dependent is returned.
 * If the field's name S is not found,
 *   CXTypeLayoutError_InvalidFieldName is returned.
 */
foreign func clang_Cursor_getOffsetOfField(C: CXCursor): Int64

/**
 * Determine whether the given cursor represents an anonymous
 * tag or namespace
 */
foreign func clang_Cursor_isAnonymous(C: CXCursor): UInt32

/**
 * Determine whether the given cursor represents an anonymous record
 * declaration.
 */
foreign func clang_Cursor_isAnonymousRecordDecl(C: CXCursor): UInt32

/**
 * Determine whether the given cursor represents an inline namespace
 * declaration.
 */
foreign func clang_Cursor_isInlineNamespace(C: CXCursor): UInt32

type CXRefQualifierKind = Int32

/** No ref-qualifier was provided. */
const CXRefQualifier_None: CXRefQualifierKind = 0

/** An lvalue ref-qualifier was provided (\c &). */
const CXRefQualifier_LValue: CXRefQualifierKind = 1

/** An rvalue ref-qualifier was provided (\c &&). */
const CXRefQualifier_RValue: CXRefQualifierKind = 2

/**
 * Returns the number of template arguments for given template
 * specialization, or -1 if type \c T is not a template specialization.
 */
foreign func clang_Type_getNumTemplateArguments(T: CXType): Int32

/**
 * Returns the type template argument of a template class specialization
 * at given index.
 *
 * This function only returns template type arguments and does not handle
 * template template arguments or variadic packs.
 */
foreign func clang_Type_getTemplateArgumentAsType(T: CXType, i: UInt32): CXType

/**
 * Retrieve the ref-qualifier kind of a function or method.
 *
 * The ref-qualifier is returned for C++ functions or methods. For other types
 * or non-C++ declarations, CXRefQualifier_None is returned.
 */
foreign func clang_Type_getCXXRefQualifier(T: CXType): CXRefQualifierKind

/**
 * Returns 1 if the base class specified by the cursor with kind
 *   CX_CXXBaseSpecifier is virtual.
 */
foreign func clang_isVirtualBase(arg0: CXCursor): UInt32

/**
 * Represents the C++ access control level to a base class for a
 * cursor with kind CX_CXXBaseSpecifier.
 */
type CX_CXXAccessSpecifier = Int32

const CX_CXXInvalidAccessSpecifier: CX_CXXAccessSpecifier = 0

const CX_CXXPublic: CX_CXXAccessSpecifier = 1

const CX_CXXProtected: CX_CXXAccessSpecifier = 2

const CX_CXXPrivate: CX_CXXAccessSpecifier = 3

/**
 * Returns the access control level for the referenced object.
 *
 * If the cursor refers to a C++ declaration, its access control level within
 * its parent scope is returned. Otherwise, if the cursor refers to a base
 * specifier or access specifier, the specifier itself is returned.
 */
foreign func clang_getCXXAccessSpecifier(arg0: CXCursor): CX_CXXAccessSpecifier

/**
 * Represents the storage classes as declared in the source. CX_SC_Invalid
 * was added for the case that the passed cursor in not a declaration.
 */
type CX_StorageClass = Int32

const CX_SC_Invalid: CX_StorageClass = 0

const CX_SC_None: CX_StorageClass = 1

const CX_SC_Extern: CX_StorageClass = 2

const CX_SC_Static: CX_StorageClass = 3

const CX_SC_PrivateExtern: CX_StorageClass = 4

const CX_SC_OpenCLWorkGroupLocal: CX_StorageClass = 5

const CX_SC_Auto: CX_StorageClass = 6

const CX_SC_Register: CX_StorageClass = 7

/**
 * Represents a specific kind of binary operator which can appear at a cursor.
 */
type CX_BinaryOperatorKind = Int32

const CX_BO_Invalid: CX_BinaryOperatorKind = 0

const CX_BO_PtrMemD: CX_BinaryOperatorKind = 1

const CX_BO_PtrMemI: CX_BinaryOperatorKind = 2

const CX_BO_Mul: CX_BinaryOperatorKind = 3

const CX_BO_Div: CX_BinaryOperatorKind = 4

const CX_BO_Rem: CX_BinaryOperatorKind = 5

const CX_BO_Add: CX_BinaryOperatorKind = 6

const CX_BO_Sub: CX_BinaryOperatorKind = 7

const CX_BO_Shl: CX_BinaryOperatorKind = 8

const CX_BO_Shr: CX_BinaryOperatorKind = 9

const CX_BO_Cmp: CX_BinaryOperatorKind = 10

const CX_BO_LT: CX_BinaryOperatorKind = 11

const CX_BO_GT: CX_BinaryOperatorKind = 12

const CX_BO_LE: CX_BinaryOperatorKind = 13

const CX_BO_GE: CX_BinaryOperatorKind = 14

const CX_BO_EQ: CX_BinaryOperatorKind = 15

const CX_BO_NE: CX_BinaryOperatorKind = 16

const CX_BO_And: CX_BinaryOperatorKind = 17

const CX_BO_Xor: CX_BinaryOperatorKind = 18

const CX_BO_Or: CX_BinaryOperatorKind = 19

const CX_BO_LAnd: CX_BinaryOperatorKind = 20

const CX_BO_LOr: CX_BinaryOperatorKind = 21

const CX_BO_Assign: CX_BinaryOperatorKind = 22

const CX_BO_MulAssign: CX_BinaryOperatorKind = 23

const CX_BO_DivAssign: CX_BinaryOperatorKind = 24

const CX_BO_RemAssign: CX_BinaryOperatorKind = 25

const CX_BO_AddAssign: CX_BinaryOperatorKind = 26

const CX_BO_SubAssign: CX_BinaryOperatorKind = 27

const CX_BO_ShlAssign: CX_BinaryOperatorKind = 28

const CX_BO_ShrAssign: CX_BinaryOperatorKind = 29

const CX_BO_AndAssign: CX_BinaryOperatorKind = 30

const CX_BO_XorAssign: CX_BinaryOperatorKind = 31

const CX_BO_OrAssign: CX_BinaryOperatorKind = 32

const CX_BO_Comma: CX_BinaryOperatorKind = 33

const CX_BO_LAST: CX_BinaryOperatorKind = 33

/**
 * \brief Returns the operator code for the binary operator.
 */
foreign func clang_Cursor_getBinaryOpcode(C: CXCursor): CX_BinaryOperatorKind

/**
 * \brief Returns a string containing the spelling of the binary operator.
 */
foreign func clang_Cursor_getBinaryOpcodeStr(Op: CX_BinaryOperatorKind): CXString

/**
 * Returns the storage class for a function or variable declaration.
 *
 * If the passed in Cursor is not a function or variable declaration,
 * CX_SC_Invalid is returned else the storage class.
 */
foreign func clang_Cursor_getStorageClass(arg0: CXCursor): CX_StorageClass

/**
 * Determine the number of overloaded declarations referenced by a
 * \c CXCursor_OverloadedDeclRef cursor.
 *
 * \param cursor The cursor whose overloaded declarations are being queried.
 *
 * \returns The number of overloaded declarations referenced by \c cursor. If it
 * is not a \c CXCursor_OverloadedDeclRef cursor, returns 0.
 */
foreign func clang_getNumOverloadedDecls(cursor: CXCursor): UInt32

/**
 * Retrieve a cursor for one of the overloaded declarations referenced
 * by a \c CXCursor_OverloadedDeclRef cursor.
 *
 * \param cursor The cursor whose overloaded declarations are being queried.
 *
 * \param index The zero-based index into the set of overloaded declarations in
 * the cursor.
 *
 * \returns A cursor representing the declaration referenced by the given
 * \c cursor at the specified \c index. If the cursor does not have an
 * associated set of overloaded declarations, or if the index is out of bounds,
 * returns \c clang_getNullCursor();
 */
foreign func clang_getOverloadedDecl(cursor: CXCursor, index: UInt32): CXCursor

/**
 * For cursors representing an iboutletcollection attribute,
 *  this function returns the collection element type.
 *
 */
foreign func clang_getIBOutletCollectionType(arg0: CXCursor): CXType

/**
 * Describes how the traversal of the children of a particular
 * cursor should proceed after visiting a particular child cursor.
 *
 * A value of this enumeration type should be returned by each
 * \c CXCursorVisitor to indicate how clang_visitChildren() proceed.
 */
type CXChildVisitResult = Int32

/**
   * Terminates the cursor traversal.
   */
const CXChildVisit_Break: CXChildVisitResult = 0

/**
   * Continues the cursor traversal with the next sibling of
   * the cursor just visited, without visiting its children.
   */
const CXChildVisit_Continue: CXChildVisitResult = 1

/**
   * Recursively traverse the children of this cursor, using
   * the same visitor and client data.
   */
const CXChildVisit_Recurse: CXChildVisitResult = 2

/**
 * Visit the children of a particular cursor.
 *
 * This function visits all the direct children of the given cursor,
 * invoking the given \p visitor function with the cursors of each
 * visited child. The traversal may be recursive, if the visitor returns
 * \c CXChildVisit_Recurse. The traversal may also be ended prematurely, if
 * the visitor returns \c CXChildVisit_Break.
 *
 * \param parent the cursor whose child may be visited. All kinds of
 * cursors can be visited, including invalid cursors (which, by
 * definition, have no children).
 *
 * \param visitor the visitor function that will be invoked for each
 * child of \p parent.
 *
 * \param client_data pointer data supplied by the client, which will
 * be passed to the visitor each time it is invoked.
 *
 * \returns a non-zero value if the traversal was terminated
 * prematurely by the visitor returning \c CXChildVisit_Break.
 */
foreign func clang_visitChildren(parent: CXCursor, visitor: CFunc<(CXCursor, CXCursor, CPointer<Unit>) -> CXChildVisitResult>, client_data: CPointer<Unit>): UInt32

/**
 * Visits the children of a cursor using the specified block.  Behaves
 * identically to clang_visitChildren() in all other respects.
 */
foreign func clang_visitChildrenWithBlock(parent: CXCursor, block: CPointer<_CXChildVisitResult>): UInt32

/**
 * Retrieve a Unified Symbol Resolution (USR) for the entity referenced
 * by the given cursor.
 *
 * A Unified Symbol Resolution (USR) is a string that identifies a particular
 * entity (function, class, variable, etc.) within a program. USRs can be
 * compared across translation units to determine, e.g., when references in
 * one translation refer to an entity defined in another translation unit.
 */
foreign func clang_getCursorUSR(arg0: CXCursor): CXString

/**
 * Construct a USR for a specified Objective-C class.
 */
foreign func clang_constructUSR_ObjCClass(class_name: CString): CXString

/**
 * Construct a USR for a specified Objective-C category.
 */
foreign func clang_constructUSR_ObjCCategory(class_name: CString, category_name: CString): CXString

/**
 * Construct a USR for a specified Objective-C protocol.
 */
foreign func clang_constructUSR_ObjCProtocol(protocol_name: CString): CXString

/**
 * Construct a USR for a specified Objective-C instance variable and
 *   the USR for its containing class.
 */
foreign func clang_constructUSR_ObjCIvar(name: CString, classUSR: CXString): CXString

/**
 * Construct a USR for a specified Objective-C method and
 *   the USR for its containing class.
 */
foreign func clang_constructUSR_ObjCMethod(name: CString, isInstanceMethod: UInt32, classUSR: CXString): CXString

/**
 * Construct a USR for a specified Objective-C property and the USR
 *  for its containing class.
 */
foreign func clang_constructUSR_ObjCProperty(property: CString, classUSR: CXString): CXString

/**
 * Retrieve a name for the entity referenced by this cursor.
 */
foreign func clang_getCursorSpelling(arg0: CXCursor): CXString

/**
 * Retrieve a range for a piece that forms the cursors spelling name.
 * Most of the times there is only one range for the complete spelling but for
 * Objective-C methods and Objective-C message expressions, there are multiple
 * pieces for each selector identifier.
 *
 * \param pieceIndex the index of the spelling name piece. If this is greater
 * than the actual number of pieces, it will return a NULL (invalid) range.
 *
 * \param options Reserved.
 */
foreign func clang_Cursor_getSpellingNameRange(arg0: CXCursor, pieceIndex: UInt32, options: UInt32): CXSourceRange

/**
 * Properties for the printing policy.
 *
 * See \c clang::PrintingPolicy for more information.
 */
type CXPrintingPolicyProperty = Int32

const CXPrintingPolicy_Indentation: CXPrintingPolicyProperty = 0

const CXPrintingPolicy_SuppressSpecifiers: CXPrintingPolicyProperty = 1

const CXPrintingPolicy_SuppressTagKeyword: CXPrintingPolicyProperty = 2

const CXPrintingPolicy_IncludeTagDefinition: CXPrintingPolicyProperty = 3

const CXPrintingPolicy_SuppressScope: CXPrintingPolicyProperty = 4

const CXPrintingPolicy_SuppressUnwrittenScope: CXPrintingPolicyProperty = 5

const CXPrintingPolicy_SuppressInitializers: CXPrintingPolicyProperty = 6

const CXPrintingPolicy_ConstantArraySizeAsWritten: CXPrintingPolicyProperty = 7

const CXPrintingPolicy_AnonymousTagLocations: CXPrintingPolicyProperty = 8

const CXPrintingPolicy_SuppressStrongLifetime: CXPrintingPolicyProperty = 9

const CXPrintingPolicy_SuppressLifetimeQualifiers: CXPrintingPolicyProperty = 10

const CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors: CXPrintingPolicyProperty = 11

const CXPrintingPolicy_Bool: CXPrintingPolicyProperty = 12

const CXPrintingPolicy_Restrict: CXPrintingPolicyProperty = 13

const CXPrintingPolicy_Alignof: CXPrintingPolicyProperty = 14

const CXPrintingPolicy_UnderscoreAlignof: CXPrintingPolicyProperty = 15

const CXPrintingPolicy_UseVoidForZeroParams: CXPrintingPolicyProperty = 16

const CXPrintingPolicy_TerseOutput: CXPrintingPolicyProperty = 17

const CXPrintingPolicy_PolishForDeclaration: CXPrintingPolicyProperty = 18

const CXPrintingPolicy_Half: CXPrintingPolicyProperty = 19

const CXPrintingPolicy_MSWChar: CXPrintingPolicyProperty = 20

const CXPrintingPolicy_IncludeNewlines: CXPrintingPolicyProperty = 21

const CXPrintingPolicy_MSVCFormatting: CXPrintingPolicyProperty = 22

const CXPrintingPolicy_ConstantsAsWritten: CXPrintingPolicyProperty = 23

const CXPrintingPolicy_SuppressImplicitBase: CXPrintingPolicyProperty = 24

const CXPrintingPolicy_FullyQualifiedName: CXPrintingPolicyProperty = 25

const CXPrintingPolicy_LastProperty: CXPrintingPolicyProperty = 25

/**
 * Get a property value for the given printing policy.
 */
foreign func clang_PrintingPolicy_getProperty(Policy: CPointer<Unit>, Property: CXPrintingPolicyProperty): UInt32

/**
 * Set a property value for the given printing policy.
 */
foreign func clang_PrintingPolicy_setProperty(Policy: CPointer<Unit>, Property: CXPrintingPolicyProperty, Value: UInt32): Unit

/**
 * Retrieve the default policy for the cursor.
 *
 * The policy should be released after use with \c
 * clang_PrintingPolicy_dispose.
 */
foreign func clang_getCursorPrintingPolicy(arg0: CXCursor): CPointer<Unit>

/**
 * Release a printing policy.
 */
foreign func clang_PrintingPolicy_dispose(Policy: CPointer<Unit>): Unit

/**
 * Pretty print declarations.
 *
 * \param Cursor The cursor representing a declaration.
 *
 * \param Policy The policy to control the entities being printed. If
 * NULL, a default policy is used.
 *
 * \returns The pretty printed declaration or the empty string for
 * other cursors.
 */
foreign func clang_getCursorPrettyPrinted(Cursor: CXCursor, Policy: CPointer<Unit>): CXString

/**
 * Retrieve the display name for the entity referenced by this cursor.
 *
 * The display name contains extra information that helps identify the cursor,
 * such as the parameters of a function or template or the arguments of a
 * class template specialization.
 */
foreign func clang_getCursorDisplayName(arg0: CXCursor): CXString

/** For a cursor that is a reference, retrieve a cursor representing the
 * entity that it references.
 *
 * Reference cursors refer to other entities in the AST. For example, an
 * Objective-C superclass reference cursor refers to an Objective-C class.
 * This function produces the cursor for the Objective-C class from the
 * cursor for the superclass reference. If the input cursor is a declaration or
 * definition, it returns that declaration or definition unchanged.
 * Otherwise, returns the NULL cursor.
 */
foreign func clang_getCursorReferenced(arg0: CXCursor): CXCursor

/**
 *  For a cursor that is either a reference to or a declaration
 *  of some entity, retrieve a cursor that describes the definition of
 *  that entity.
 *
 *  Some entities can be declared multiple times within a translation
 *  unit, but only one of those declarations can also be a
 *  definition. For example, given:
 *
 *  \code
 *  int f(int, int);
 *  int g(int x, int y) { return f(x, y); }
 *  int f(int a, int b) { return a + b; }
 *  int f(int, int);
 *  \endcode
 *
 *  there are three declarations of the function "f", but only the
 *  second one is a definition. The clang_getCursorDefinition()
 *  function will take any cursor pointing to a declaration of "f"
 *  (the first or fourth lines of the example) or a cursor referenced
 *  that uses "f" (the call to "f' inside "g") and will return a
 *  declaration cursor pointing to the definition (the second "f"
 *  declaration).
 *
 *  If given a cursor for which there is no corresponding definition,
 *  e.g., because there is no definition of that entity within this
 *  translation unit, returns a NULL cursor.
 */
foreign func clang_getCursorDefinition(arg0: CXCursor): CXCursor

/**
 * Determine whether the declaration pointed to by this cursor
 * is also a definition of that entity.
 */
foreign func clang_isCursorDefinition(arg0: CXCursor): UInt32

/**
 * Retrieve the canonical cursor corresponding to the given cursor.
 *
 * In the C family of languages, many kinds of entities can be declared several
 * times within a single translation unit. For example, a structure type can
 * be forward-declared (possibly multiple times) and later defined:
 *
 * \code
 * struct X;
 * struct X;
 * struct X {
 *   int member;
 * };
 * \endcode
 *
 * The declarations and the definition of \c X are represented by three
 * different cursors, all of which are declarations of the same underlying
 * entity. One of these cursor is considered the "canonical" cursor, which
 * is effectively the representative for the underlying entity. One can
 * determine if two cursors are declarations of the same underlying entity by
 * comparing their canonical cursors.
 *
 * \returns The canonical cursor for the entity referred to by the given cursor.
 */
foreign func clang_getCanonicalCursor(arg0: CXCursor): CXCursor

/**
 * If the cursor points to a selector identifier in an Objective-C
 * method or message expression, this returns the selector index.
 *
 * After getting a cursor with #clang_getCursor, this can be called to
 * determine if the location points to a selector identifier.
 *
 * \returns The selector index if the cursor is an Objective-C method or message
 * expression and the cursor is pointing to a selector identifier, or -1
 * otherwise.
 */
foreign func clang_Cursor_getObjCSelectorIndex(arg0: CXCursor): Int32

/**
 * Given a cursor pointing to a C++ method call or an Objective-C
 * message, returns non-zero if the method/message is "dynamic", meaning:
 *
 * For a C++ method: the call is virtual.
 * For an Objective-C message: the receiver is an object instance, not 'super'
 * or a specific class.
 *
 * If the method/message is "static" or the cursor does not point to a
 * method/message, it will return zero.
 */
foreign func clang_Cursor_isDynamicCall(C: CXCursor): Int32

/**
 * Given a cursor pointing to an Objective-C message or property
 * reference, or C++ method call, returns the CXType of the receiver.
 */
foreign func clang_Cursor_getReceiverType(C: CXCursor): CXType

/**
 * Property attributes for a \c CXCursor_ObjCPropertyDecl.
 */
type CXObjCPropertyAttrKind = Int32

const CXObjCPropertyAttr_noattr: CXObjCPropertyAttrKind = 0

const CXObjCPropertyAttr_readonly: CXObjCPropertyAttrKind = 1

const CXObjCPropertyAttr_getter: CXObjCPropertyAttrKind = 2

const CXObjCPropertyAttr_assign: CXObjCPropertyAttrKind = 4

const CXObjCPropertyAttr_readwrite: CXObjCPropertyAttrKind = 8

const CXObjCPropertyAttr_retain: CXObjCPropertyAttrKind = 16

const CXObjCPropertyAttr_copy: CXObjCPropertyAttrKind = 32

const CXObjCPropertyAttr_nonatomic: CXObjCPropertyAttrKind = 64

const CXObjCPropertyAttr_setter: CXObjCPropertyAttrKind = 128

const CXObjCPropertyAttr_atomic: CXObjCPropertyAttrKind = 256

const CXObjCPropertyAttr_weak: CXObjCPropertyAttrKind = 512

const CXObjCPropertyAttr_strong: CXObjCPropertyAttrKind = 1024

const CXObjCPropertyAttr_unsafe_unretained: CXObjCPropertyAttrKind = 2048

const CXObjCPropertyAttr_class: CXObjCPropertyAttrKind = 4096

/**
 * Given a cursor that represents a property declaration, return the
 * associated property attributes. The bits are formed from
 * \c CXObjCPropertyAttrKind.
 *
 * \param reserved Reserved for future use, pass 0.
 */
foreign func clang_Cursor_getObjCPropertyAttributes(C: CXCursor, reserved: UInt32): UInt32

/**
 * Given a cursor that represents a property declaration, return the
 * name of the method that implements the getter.
 */
foreign func clang_Cursor_getObjCPropertyGetterName(C: CXCursor): CXString

/**
 * Given a cursor that represents a property declaration, return the
 * name of the method that implements the setter, if any.
 */
foreign func clang_Cursor_getObjCPropertySetterName(C: CXCursor): CXString

/**
 * 'Qualifiers' written next to the return and parameter types in
 * Objective-C method declarations.
 */
type CXObjCDeclQualifierKind = Int32

const CXObjCDeclQualifier_None: CXObjCDeclQualifierKind = 0

const CXObjCDeclQualifier_In: CXObjCDeclQualifierKind = 1

const CXObjCDeclQualifier_Inout: CXObjCDeclQualifierKind = 2

const CXObjCDeclQualifier_Out: CXObjCDeclQualifierKind = 4

const CXObjCDeclQualifier_Bycopy: CXObjCDeclQualifierKind = 8

const CXObjCDeclQualifier_Byref: CXObjCDeclQualifierKind = 16

const CXObjCDeclQualifier_Oneway: CXObjCDeclQualifierKind = 32

/**
 * Given a cursor that represents an Objective-C method or parameter
 * declaration, return the associated Objective-C qualifiers for the return
 * type or the parameter respectively. The bits are formed from
 * CXObjCDeclQualifierKind.
 */
foreign func clang_Cursor_getObjCDeclQualifiers(C: CXCursor): UInt32

/**
 * Given a cursor that represents an Objective-C method or property
 * declaration, return non-zero if the declaration was affected by "\@optional".
 * Returns zero if the cursor is not such a declaration or it is "\@required".
 */
foreign func clang_Cursor_isObjCOptional(C: CXCursor): UInt32

/**
 * Returns non-zero if the given cursor is a variadic function or method.
 */
foreign func clang_Cursor_isVariadic(C: CXCursor): UInt32

/**
 * Returns non-zero if the given cursor points to a symbol marked with
 * external_source_symbol attribute.
 *
 * \param language If non-NULL, and the attribute is present, will be set to
 * the 'language' string from the attribute.
 *
 * \param definedIn If non-NULL, and the attribute is present, will be set to
 * the 'definedIn' string from the attribute.
 *
 * \param isGenerated If non-NULL, and the attribute is present, will be set to
 * non-zero if the 'generated_declaration' is set in the attribute.
 */
foreign func clang_Cursor_isExternalSymbol(C: CXCursor, language: CPointer<CXString>, definedIn: CPointer<CXString>, isGenerated: CPointer<UInt32>): UInt32

/**
 * Given a cursor that represents a declaration, return the associated
 * comment's source range.  The range may include multiple consecutive comments
 * with whitespace in between.
 */
foreign func clang_Cursor_getCommentRange(C: CXCursor): CXSourceRange

/**
 * Given a cursor that represents a declaration, return the associated
 * comment text, including comment markers.
 */
foreign func clang_Cursor_getRawCommentText(C: CXCursor): CXString

/**
 * Given a cursor that represents a documentable entity (e.g.,
 * declaration), return the associated \paragraph; otherwise return the
 * first paragraph.
 */
foreign func clang_Cursor_getBriefCommentText(C: CXCursor): CXString

/**
 * Retrieve the CXString representing the mangled name of the cursor.
 */
foreign func clang_Cursor_getMangling(arg0: CXCursor): CXString

/**
 * Retrieve the CXStrings representing the mangled symbols of the C++
 * constructor or destructor at the cursor.
 */
foreign func clang_Cursor_getCXXManglings(arg0: CXCursor): CPointer<CXStringSet>

/**
 * Retrieve the CXStrings representing the mangled symbols of the ObjC
 * class interface or implementation at the cursor.
 */
foreign func clang_Cursor_getObjCManglings(arg0: CXCursor): CPointer<CXStringSet>

/**
 * Given a CXCursor_ModuleImportDecl cursor, return the associated module.
 */
foreign func clang_Cursor_getModule(C: CXCursor): CPointer<Unit>

/**
 * Given a CXFile header file, return the module that contains it, if one
 * exists.
 */
foreign func clang_getModuleForFile(arg0: CPointer<CXTranslationUnitImpl>, arg1: CPointer<Unit>): CPointer<Unit>

/**
 * \param Module a module object.
 *
 * \returns the module file where the provided module object came from.
 */
foreign func clang_Module_getASTFile(Module: CPointer<Unit>): CPointer<Unit>

/**
 * \param Module a module object.
 *
 * \returns the parent of a sub-module or NULL if the given module is top-level,
 * e.g. for 'std.vector' it will return the 'std' module.
 */
foreign func clang_Module_getParent(Module: CPointer<Unit>): CPointer<Unit>

/**
 * \param Module a module object.
 *
 * \returns the name of the module, e.g. for the 'std.vector' sub-module it
 * will return "vector".
 */
foreign func clang_Module_getName(Module: CPointer<Unit>): CXString

/**
 * \param Module a module object.
 *
 * \returns the full name of the module, e.g. "std.vector".
 */
foreign func clang_Module_getFullName(Module: CPointer<Unit>): CXString

/**
 * \param Module a module object.
 *
 * \returns non-zero if the module is a system one.
 */
foreign func clang_Module_isSystem(Module: CPointer<Unit>): Int32

/**
 * \param Module a module object.
 *
 * \returns the number of top level headers associated with this module.
 */
foreign func clang_Module_getNumTopLevelHeaders(arg0: CPointer<CXTranslationUnitImpl>, Module: CPointer<Unit>): UInt32

/**
 * \param Module a module object.
 *
 * \param Index top level header index (zero-based).
 *
 * \returns the specified top level header associated with the module.
 */
foreign func clang_Module_getTopLevelHeader(arg0: CPointer<CXTranslationUnitImpl>, Module: CPointer<Unit>, Index: UInt32): CPointer<Unit>

/**
 * Determine if a C++ constructor is a converting constructor.
 */
foreign func clang_CXXConstructor_isConvertingConstructor(C: CXCursor): UInt32

/**
 * Determine if a C++ constructor is a copy constructor.
 */
foreign func clang_CXXConstructor_isCopyConstructor(C: CXCursor): UInt32

/**
 * Determine if a C++ constructor is the default constructor.
 */
foreign func clang_CXXConstructor_isDefaultConstructor(C: CXCursor): UInt32

/**
 * Determine if a C++ constructor is a move constructor.
 */
foreign func clang_CXXConstructor_isMoveConstructor(C: CXCursor): UInt32

/**
 * Determine if a C++ field is declared 'mutable'.
 */
foreign func clang_CXXField_isMutable(C: CXCursor): UInt32

/**
 * Determine if a C++ method is declared '= default'.
 */
foreign func clang_CXXMethod_isDefaulted(C: CXCursor): UInt32

/**
 * Determine if a C++ method is declared '= delete'.
 */
foreign func clang_CXXMethod_isDeleted(C: CXCursor): UInt32

/**
 * Determine if a C++ member function or member function template is
 * pure virtual.
 */
foreign func clang_CXXMethod_isPureVirtual(C: CXCursor): UInt32

/**
 * Determine if a C++ member function or member function template is
 * declared 'static'.
 */
foreign func clang_CXXMethod_isStatic(C: CXCursor): UInt32

/**
 * Determine if a C++ member function or member function template is
 * explicitly declared 'virtual' or if it overrides a virtual method from
 * one of the base classes.
 */
foreign func clang_CXXMethod_isVirtual(C: CXCursor): UInt32

/**
 * Determine if a C++ member function is a copy-assignment operator,
 * returning 1 if such is the case and 0 otherwise.
 *
 * > A copy-assignment operator `X::operator=` is a non-static,
 * > non-template member function of _class_ `X` with exactly one
 * > parameter of type `X`, `X&`, `const X&`, `volatile X&` or `const
 * > volatile X&`.
 *
 * That is, for example, the `operator=` in:
 *
 *    class Foo {
 *        bool operator=(const volatile Foo&);
 *    };
 *
 * Is a copy-assignment operator, while the `operator=` in:
 *
 *    class Bar {
 *        bool operator=(const int&);
 *    };
 *
 * Is not.
 */
foreign func clang_CXXMethod_isCopyAssignmentOperator(C: CXCursor): UInt32

/**
 * Determine if a C++ member function is a move-assignment operator,
 * returning 1 if such is the case and 0 otherwise.
 *
 * > A move-assignment operator `X::operator=` is a non-static,
 * > non-template member function of _class_ `X` with exactly one
 * > parameter of type `X&&`, `const X&&`, `volatile X&&` or `const
 * > volatile X&&`.
 *
 * That is, for example, the `operator=` in:
 *
 *    class Foo {
 *        bool operator=(const volatile Foo&&);
 *    };
 *
 * Is a move-assignment operator, while the `operator=` in:
 *
 *    class Bar {
 *        bool operator=(const int&&);
 *    };
 *
 * Is not.
 */
foreign func clang_CXXMethod_isMoveAssignmentOperator(C: CXCursor): UInt32

/**
 * Determines if a C++ constructor or conversion function was declared
 * explicit, returning 1 if such is the case and 0 otherwise.
 *
 * Constructors or conversion functions are declared explicit through
 * the use of the explicit specifier.
 *
 * For example, the following constructor and conversion function are
 * not explicit as they lack the explicit specifier:
 *
 *     class Foo {
 *         Foo();
 *         operator int();
 *     };
 *
 * While the following constructor and conversion function are
 * explicit as they are declared with the explicit specifier.
 *
 *     class Foo {
 *         explicit Foo();
 *         explicit operator int();
 *     };
 *
 * This function will return 0 when given a cursor pointing to one of
 * the former declarations and it will return 1 for a cursor pointing
 * to the latter declarations.
 *
 * The explicit specifier allows the user to specify a
 * conditional compile-time expression whose value decides
 * whether the marked element is explicit or not.
 *
 * For example:
 *
 *     constexpr bool foo(int i) { return i % 2 == 0; }
 *
 *     class Foo {
 *          explicit(foo(1)) Foo();
 *          explicit(foo(2)) operator int();
 *     }
 *
 * This function will return 0 for the constructor and 1 for
 * the conversion function.
 */
foreign func clang_CXXMethod_isExplicit(C: CXCursor): UInt32

/**
 * Determine if a C++ record is abstract, i.e. whether a class or struct
 * has a pure virtual member function.
 */
foreign func clang_CXXRecord_isAbstract(C: CXCursor): UInt32

/**
 * Determine if an enum declaration refers to a scoped enum.
 */
foreign func clang_EnumDecl_isScoped(C: CXCursor): UInt32

/**
 * Determine if a C++ member function or member function template is
 * declared 'const'.
 */
foreign func clang_CXXMethod_isConst(C: CXCursor): UInt32

/**
 * Given a cursor that represents a template, determine
 * the cursor kind of the specializations would be generated by instantiating
 * the template.
 *
 * This routine can be used to determine what flavor of function template,
 * class template, or class template partial specialization is stored in the
 * cursor. For example, it can describe whether a class template cursor is
 * declared with "struct", "class" or "union".
 *
 * \param C The cursor to query. This cursor should represent a template
 * declaration.
 *
 * \returns The cursor kind of the specializations that would be generated
 * by instantiating the template \p C. If \p C is not a template, returns
 * \c CXCursor_NoDeclFound.
 */
foreign func clang_getTemplateCursorKind(C: CXCursor): CXCursorKind

/**
 * Given a cursor that may represent a specialization or instantiation
 * of a template, retrieve the cursor that represents the template that it
 * specializes or from which it was instantiated.
 *
 * This routine determines the template involved both for explicit
 * specializations of templates and for implicit instantiations of the template,
 * both of which are referred to as "specializations". For a class template
 * specialization (e.g., \c std::vector<bool>), this routine will return
 * either the primary template (\c std::vector) or, if the specialization was
 * instantiated from a class template partial specialization, the class template
 * partial specialization. For a class template partial specialization and a
 * function template specialization (including instantiations), this
 * this routine will return the specialized template.
 *
 * For members of a class template (e.g., member functions, member classes, or
 * static data members), returns the specialized or instantiated member.
 * Although not strictly "templates" in the C++ language, members of class
 * templates have the same notions of specializations and instantiations that
 * templates do, so this routine treats them similarly.
 *
 * \param C A cursor that may be a specialization of a template or a member
 * of a template.
 *
 * \returns If the given cursor is a specialization or instantiation of a
 * template or a member thereof, the template or member that it specializes or
 * from which it was instantiated. Otherwise, returns a NULL cursor.
 */
foreign func clang_getSpecializedCursorTemplate(C: CXCursor): CXCursor

/**
 * Given a cursor that references something else, return the source range
 * covering that reference.
 *
 * \param C A cursor pointing to a member reference, a declaration reference, or
 * an operator call.
 * \param NameFlags A bitset with three independent flags:
 * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and
 * CXNameRange_WantSinglePiece.
 * \param PieceIndex For contiguous names or when passing the flag
 * CXNameRange_WantSinglePiece, only one piece with index 0 is
 * available. When the CXNameRange_WantSinglePiece flag is not passed for a
 * non-contiguous names, this index can be used to retrieve the individual
 * pieces of the name. See also CXNameRange_WantSinglePiece.
 *
 * \returns The piece of the name pointed to by the given cursor. If there is no
 * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.
 */
foreign func clang_getCursorReferenceNameRange(C: CXCursor, NameFlags: UInt32, PieceIndex: UInt32): CXSourceRange

type CXNameRefFlags = Int32

/**
   * Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the
   * range.
   */
const CXNameRange_WantQualifier: CXNameRefFlags = 1

/**
   * Include the explicit template arguments, e.g. \<int> in x.f<int>,
   * in the range.
   */
const CXNameRange_WantTemplateArgs: CXNameRefFlags = 2

/**
   * If the name is non-contiguous, return the full spanning range.
   *
   * Non-contiguous names occur in Objective-C when a selector with two or more
   * parameters is used, or in C++ when using an operator:
   * \code
   * [object doSomething:here withValue:there]; // Objective-C
   * return some_vector[1]; // C++
   * \endcode
   */
const CXNameRange_WantSinglePiece: CXNameRefFlags = 4

/**
 * Describes a kind of token.
 */
type CXTokenKind = Int32

/**
   * A token that contains some kind of punctuation.
   */
const CXToken_Punctuation: CXTokenKind = 0

/**
   * A language keyword.
   */
const CXToken_Keyword: CXTokenKind = 1

/**
   * An identifier (that is not a keyword).
   */
const CXToken_Identifier: CXTokenKind = 2

/**
   * A numeric, string, or character literal.
   */
const CXToken_Literal: CXTokenKind = 3

/**
   * A comment.
   */
const CXToken_Comment: CXTokenKind = 4

/**
 * Get the raw lexical token starting with the given location.
 *
 * \param TU the translation unit whose text is being tokenized.
 *
 * \param Location the source location with which the token starts.
 *
 * \returns The token starting with the given location or NULL if no such token
 * exist. The returned pointer must be freed with clang_disposeTokens before the
 * translation unit is destroyed.
 */
foreign func clang_getToken(TU: CPointer<CXTranslationUnitImpl>, Location: CXSourceLocation): CPointer<CXToken>

/**
 * Determine the kind of the given token.
 */
foreign func clang_getTokenKind(arg0: CXToken): CXTokenKind

/**
 * Determine the spelling of the given token.
 *
 * The spelling of a token is the textual representation of that token, e.g.,
 * the text of an identifier or keyword.
 */
foreign func clang_getTokenSpelling(arg0: CPointer<CXTranslationUnitImpl>, arg1: CXToken): CXString

/**
 * Retrieve the source location of the given token.
 */
foreign func clang_getTokenLocation(arg0: CPointer<CXTranslationUnitImpl>, arg1: CXToken): CXSourceLocation

/**
 * Retrieve a source range that covers the given token.
 */
foreign func clang_getTokenExtent(arg0: CPointer<CXTranslationUnitImpl>, arg1: CXToken): CXSourceRange

/**
 * Tokenize the source code described by the given range into raw
 * lexical tokens.
 *
 * \param TU the translation unit whose text is being tokenized.
 *
 * \param Range the source range in which text should be tokenized. All of the
 * tokens produced by tokenization will fall within this source range,
 *
 * \param Tokens this pointer will be set to point to the array of tokens
 * that occur within the given source range. The returned pointer must be
 * freed with clang_disposeTokens() before the translation unit is destroyed.
 *
 * \param NumTokens will be set to the number of tokens in the \c *Tokens
 * array.
 *
 */
foreign func clang_tokenize(TU: CPointer<CXTranslationUnitImpl>, Range: CXSourceRange, Tokens: CPointer<CPointer<CXToken>>, NumTokens: CPointer<UInt32>): Unit

/**
 * Annotate the given set of tokens by providing cursors for each token
 * that can be mapped to a specific entity within the abstract syntax tree.
 *
 * This token-annotation routine is equivalent to invoking
 * clang_getCursor() for the source locations of each of the
 * tokens. The cursors provided are filtered, so that only those
 * cursors that have a direct correspondence to the token are
 * accepted. For example, given a function call \c f(x),
 * clang_getCursor() would provide the following cursors:
 *
 *   * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.
 *   * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.
 *   * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.
 *
 * Only the first and last of these cursors will occur within the
 * annotate, since the tokens "f" and "x' directly refer to a function
 * and a variable, respectively, but the parentheses are just a small
 * part of the full syntax of the function call expression, which is
 * not provided as an annotation.
 *
 * \param TU the translation unit that owns the given tokens.
 *
 * \param Tokens the set of tokens to annotate.
 *
 * \param NumTokens the number of tokens in \p Tokens.
 *
 * \param Cursors an array of \p NumTokens cursors, whose contents will be
 * replaced with the cursors corresponding to each token.
 */
foreign func clang_annotateTokens(TU: CPointer<CXTranslationUnitImpl>, Tokens: CPointer<CXToken>, NumTokens: UInt32, Cursors: CPointer<CXCursor>): Unit

/**
 * Free the given set of tokens.
 */
foreign func clang_disposeTokens(TU: CPointer<CXTranslationUnitImpl>, Tokens: CPointer<CXToken>, NumTokens: UInt32): Unit

/**
 * \defgroup CINDEX_DEBUG Debugging facilities
 *
 * These routines are used for testing and debugging, only, and should not
 * be relied upon.
 *
 * @{
 */
foreign func clang_getCursorKindSpelling(Kind: CXCursorKind): CXString

foreign func clang_getDefinitionSpellingAndExtent(arg0: CXCursor, startBuf: CPointer<CString>, endBuf: CPointer<CString>, startLine: CPointer<UInt32>, startColumn: CPointer<UInt32>, endLine: CPointer<UInt32>, endColumn: CPointer<UInt32>): Unit

foreign func clang_enableStackTraces(): Unit

foreign func clang_executeOnThread(fn: CFunc<(CPointer<Unit>) -> Unit>, user_data: CPointer<Unit>, stack_size: UInt32): Unit

/**
 * Describes a single piece of text within a code-completion string.
 *
 * Each "chunk" within a code-completion string (\c CXCompletionString) is
 * either a piece of text with a specific "kind" that describes how that text
 * should be interpreted by the client or is another completion string.
 */
type CXCompletionChunkKind = Int32

/**
   * A code-completion string that describes "optional" text that
   * could be a part of the template (but is not required).
   *
   * The Optional chunk is the only kind of chunk that has a code-completion
   * string for its representation, which is accessible via
   * \c clang_getCompletionChunkCompletionString(). The code-completion string
   * describes an additional part of the template that is completely optional.
   * For example, optional chunks can be used to describe the placeholders for
   * arguments that match up with defaulted function parameters, e.g. given:
   *
   * \code
   * void f(int x, float y = 3.14, double z = 2.71828);
   * \endcode
   *
   * The code-completion string for this function would contain:
   *   - a TypedText chunk for "f".
   *   - a LeftParen chunk for "(".
   *   - a Placeholder chunk for "int x"
   *   - an Optional chunk containing the remaining defaulted arguments, e.g.,
   *       - a Comma chunk for ","
   *       - a Placeholder chunk for "float y"
   *       - an Optional chunk containing the last defaulted argument:
   *           - a Comma chunk for ","
   *           - a Placeholder chunk for "double z"
   *   - a RightParen chunk for ")"
   *
   * There are many ways to handle Optional chunks. Two simple approaches are:
   *   - Completely ignore optional chunks, in which case the template for the
   *     function "f" would only include the first parameter ("int x").
   *   - Fully expand all optional chunks, in which case the template for the
   *     function "f" would have all of the parameters.
   */
const CXCompletionChunk_Optional: CXCompletionChunkKind = 0

/**
   * Text that a user would be expected to type to get this
   * code-completion result.
   *
   * There will be exactly one "typed text" chunk in a semantic string, which
   * will typically provide the spelling of a keyword or the name of a
   * declaration that could be used at the current code point. Clients are
   * expected to filter the code-completion results based on the text in this
   * chunk.
   */
const CXCompletionChunk_TypedText: CXCompletionChunkKind = 1

/**
   * Text that should be inserted as part of a code-completion result.
   *
   * A "text" chunk represents text that is part of the template to be
   * inserted into user code should this particular code-completion result
   * be selected.
   */
const CXCompletionChunk_Text: CXCompletionChunkKind = 2

/**
   * Placeholder text that should be replaced by the user.
   *
   * A "placeholder" chunk marks a place where the user should insert text
   * into the code-completion template. For example, placeholders might mark
   * the function parameters for a function declaration, to indicate that the
   * user should provide arguments for each of those parameters. The actual
   * text in a placeholder is a suggestion for the text to display before
   * the user replaces the placeholder with real code.
   */
const CXCompletionChunk_Placeholder: CXCompletionChunkKind = 3

/**
   * Informative text that should be displayed but never inserted as
   * part of the template.
   *
   * An "informative" chunk contains annotations that can be displayed to
   * help the user decide whether a particular code-completion result is the
   * right option, but which is not part of the actual template to be inserted
   * by code completion.
   */
const CXCompletionChunk_Informative: CXCompletionChunkKind = 4

/**
   * Text that describes the current parameter when code-completion is
   * referring to function call, message send, or template specialization.
   *
   * A "current parameter" chunk occurs when code-completion is providing
   * information about a parameter corresponding to the argument at the
   * code-completion point. For example, given a function
   *
   * \code
   * int add(int x, int y);
   * \endcode
   *
   * and the source code \c add(, where the code-completion point is after the
   * "(", the code-completion string will contain a "current parameter" chunk
   * for "int x", indicating that the current argument will initialize that
   * parameter. After typing further, to \c add(17, (where the code-completion
   * point is after the ","), the code-completion string will contain a
   * "current parameter" chunk to "int y".
   */
const CXCompletionChunk_CurrentParameter: CXCompletionChunkKind = 5

/**
   * A left parenthesis ('('), used to initiate a function call or
   * signal the beginning of a function parameter list.
   */
const CXCompletionChunk_LeftParen: CXCompletionChunkKind = 6

/**
   * A right parenthesis (')'), used to finish a function call or
   * signal the end of a function parameter list.
   */
const CXCompletionChunk_RightParen: CXCompletionChunkKind = 7

/**
   * A left bracket ('[').
   */
const CXCompletionChunk_LeftBracket: CXCompletionChunkKind = 8

/**
   * A right bracket (']').
   */
const CXCompletionChunk_RightBracket: CXCompletionChunkKind = 9

/**
   * A left brace ('{').
   */
const CXCompletionChunk_LeftBrace: CXCompletionChunkKind = 10

/**
   * A right brace ('}').
   */
const CXCompletionChunk_RightBrace: CXCompletionChunkKind = 11

/**
   * A left angle bracket ('<').
   */
const CXCompletionChunk_LeftAngle: CXCompletionChunkKind = 12

/**
   * A right angle bracket ('>').
   */
const CXCompletionChunk_RightAngle: CXCompletionChunkKind = 13

/**
   * A comma separator (',').
   */
const CXCompletionChunk_Comma: CXCompletionChunkKind = 14

/**
   * Text that specifies the result type of a given result.
   *
   * This special kind of informative chunk is not meant to be inserted into
   * the text buffer. Rather, it is meant to illustrate the type that an
   * expression using the given completion string would have.
   */
const CXCompletionChunk_ResultType: CXCompletionChunkKind = 15

/**
   * A colon (':').
   */
const CXCompletionChunk_Colon: CXCompletionChunkKind = 16

/**
   * A semicolon (';').
   */
const CXCompletionChunk_SemiColon: CXCompletionChunkKind = 17

/**
   * An '=' sign.
   */
const CXCompletionChunk_Equal: CXCompletionChunkKind = 18

/**
   * Horizontal space (' ').
   */
const CXCompletionChunk_HorizontalSpace: CXCompletionChunkKind = 19

/**
   * Vertical space ('\\n'), after which it is generally a good idea to
   * perform indentation.
   */
const CXCompletionChunk_VerticalSpace: CXCompletionChunkKind = 20

/**
 * Determine the kind of a particular chunk within a completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param chunk_number the 0-based index of the chunk in the completion string.
 *
 * \returns the kind of the chunk at the index \c chunk_number.
 */
foreign func clang_getCompletionChunkKind(completion_string: CPointer<Unit>, chunk_number: UInt32): CXCompletionChunkKind

/**
 * Retrieve the text associated with a particular chunk within a
 * completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param chunk_number the 0-based index of the chunk in the completion string.
 *
 * \returns the text associated with the chunk at index \c chunk_number.
 */
foreign func clang_getCompletionChunkText(completion_string: CPointer<Unit>, chunk_number: UInt32): CXString

/**
 * Retrieve the completion string associated with a particular chunk
 * within a completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param chunk_number the 0-based index of the chunk in the completion string.
 *
 * \returns the completion string associated with the chunk at index
 * \c chunk_number.
 */
foreign func clang_getCompletionChunkCompletionString(completion_string: CPointer<Unit>, chunk_number: UInt32): CPointer<Unit>

/**
 * Retrieve the number of chunks in the given code-completion string.
 */
foreign func clang_getNumCompletionChunks(completion_string: CPointer<Unit>): UInt32

/**
 * Determine the priority of this code completion.
 *
 * The priority of a code completion indicates how likely it is that this
 * particular completion is the completion that the user will select. The
 * priority is selected by various internal heuristics.
 *
 * \param completion_string The completion string to query.
 *
 * \returns The priority of this completion string. Smaller values indicate
 * higher-priority (more likely) completions.
 */
foreign func clang_getCompletionPriority(completion_string: CPointer<Unit>): UInt32

/**
 * Determine the availability of the entity that this code-completion
 * string refers to.
 *
 * \param completion_string The completion string to query.
 *
 * \returns The availability of the completion string.
 */
foreign func clang_getCompletionAvailability(completion_string: CPointer<Unit>): CXAvailabilityKind

/**
 * Retrieve the number of annotations associated with the given
 * completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \returns the number of annotations associated with the given completion
 * string.
 */
foreign func clang_getCompletionNumAnnotations(completion_string: CPointer<Unit>): UInt32

/**
 * Retrieve the annotation associated with the given completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param annotation_number the 0-based index of the annotation of the
 * completion string.
 *
 * \returns annotation string associated with the completion at index
 * \c annotation_number, or a NULL string if that annotation is not available.
 */
foreign func clang_getCompletionAnnotation(completion_string: CPointer<Unit>, annotation_number: UInt32): CXString

/**
 * Retrieve the parent context of the given completion string.
 *
 * The parent context of a completion string is the semantic parent of
 * the declaration (if any) that the code completion represents. For example,
 * a code completion for an Objective-C method would have the method's class
 * or protocol as its context.
 *
 * \param completion_string The code completion string whose parent is
 * being queried.
 *
 * \param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.
 *
 * \returns The name of the completion parent, e.g., "NSObject" if
 * the completion string represents a method in the NSObject class.
 */
foreign func clang_getCompletionParent(completion_string: CPointer<Unit>, kind: CPointer<CXCursorKind>): CXString

/**
 * Retrieve the brief documentation comment attached to the declaration
 * that corresponds to the given completion string.
 */
foreign func clang_getCompletionBriefComment(completion_string: CPointer<Unit>): CXString

/**
 * Retrieve a completion string for an arbitrary declaration or macro
 * definition cursor.
 *
 * \param cursor The cursor to query.
 *
 * \returns A non-context-sensitive completion string for declaration and macro
 * definition cursors, or NULL for other kinds of cursors.
 */
foreign func clang_getCursorCompletionString(cursor: CXCursor): CPointer<Unit>

/**
 * Retrieve the number of fix-its for the given completion index.
 *
 * Calling this makes sense only if CXCodeComplete_IncludeCompletionsWithFixIts
 * option was set.
 *
 * \param results The structure keeping all completion results
 *
 * \param completion_index The index of the completion
 *
 * \return The number of fix-its which must be applied before the completion at
 * completion_index can be applied
 */
foreign func clang_getCompletionNumFixIts(results: CPointer<CXCodeCompleteResults>, completion_index: UInt32): UInt32

/**
 * Fix-its that *must* be applied before inserting the text for the
 * corresponding completion.
 *
 * By default, clang_codeCompleteAt() only returns completions with empty
 * fix-its. Extra completions with non-empty fix-its should be explicitly
 * requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.
 *
 * For the clients to be able to compute position of the cursor after applying
 * fix-its, the following conditions are guaranteed to hold for
 * replacement_range of the stored fix-its:
 *  - Ranges in the fix-its are guaranteed to never contain the completion
 *  point (or identifier under completion point, if any) inside them, except
 *  at the start or at the end of the range.
 *  - If a fix-it range starts or ends with completion point (or starts or
 *  ends after the identifier under completion point), it will contain at
 *  least one character. It allows to unambiguously recompute completion
 *  point after applying the fix-it.
 *
 * The intuition is that provided fix-its change code around the identifier we
 * complete, but are not allowed to touch the identifier itself or the
 * completion point. One example of completions with corrections are the ones
 * replacing '.' with '->' and vice versa:
 *
 * std::unique_ptr<std::vector<int>> vec_ptr;
 * In 'vec_ptr.^', one of the completions is 'push_back', it requires
 * replacing '.' with '->'.
 * In 'vec_ptr->^', one of the completions is 'release', it requires
 * replacing '->' with '.'.
 *
 * \param results The structure keeping all completion results
 *
 * \param completion_index The index of the completion
 *
 * \param fixit_index The index of the fix-it for the completion at
 * completion_index
 *
 * \param replacement_range The fix-it range that must be replaced before the
 * completion at completion_index can be applied
 *
 * \returns The fix-it string that must replace the code at replacement_range
 * before the completion at completion_index can be applied
 */
foreign func clang_getCompletionFixIt(results: CPointer<CXCodeCompleteResults>, completion_index: UInt32, fixit_index: UInt32, replacement_range: CPointer<CXSourceRange>): CXString

/**
 * Flags that can be passed to \c clang_codeCompleteAt() to
 * modify its behavior.
 *
 * The enumerators in this enumeration can be bitwise-OR'd together to
 * provide multiple options to \c clang_codeCompleteAt().
 */
type CXCodeComplete_Flags = Int32

/**
   * Whether to include macros within the set of code
   * completions returned.
   */
const CXCodeComplete_IncludeMacros: CXCodeComplete_Flags = 1

/**
   * Whether to include code patterns for language constructs
   * within the set of code completions, e.g., for loops.
   */
const CXCodeComplete_IncludeCodePatterns: CXCodeComplete_Flags = 2

/**
   * Whether to include brief documentation within the set of code
   * completions returned.
   */
const CXCodeComplete_IncludeBriefComments: CXCodeComplete_Flags = 4

/**
   * Whether to speed up completion by omitting top- or namespace-level entities
   * defined in the preamble. There's no guarantee any particular entity is
   * omitted. This may be useful if the headers are indexed externally.
   */
const CXCodeComplete_SkipPreamble: CXCodeComplete_Flags = 8

/**
   * Whether to include completions with small
   * fix-its, e.g. change '.' to '->' on member access, etc.
   */
const CXCodeComplete_IncludeCompletionsWithFixIts: CXCodeComplete_Flags = 16

/**
 * Bits that represent the context under which completion is occurring.
 *
 * The enumerators in this enumeration may be bitwise-OR'd together if multiple
 * contexts are occurring simultaneously.
 */
type CXCompletionContext = Int32

/**
   * The context for completions is unexposed, as only Clang results
   * should be included. (This is equivalent to having no context bits set.)
   */
const CXCompletionContext_Unexposed: CXCompletionContext = 0

/**
   * Completions for any possible type should be included in the results.
   */
const CXCompletionContext_AnyType: CXCompletionContext = 1

/**
   * Completions for any possible value (variables, function calls, etc.)
   * should be included in the results.
   */
const CXCompletionContext_AnyValue: CXCompletionContext = 2

/**
   * Completions for values that resolve to an Objective-C object should
   * be included in the results.
   */
const CXCompletionContext_ObjCObjectValue: CXCompletionContext = 4

/**
   * Completions for values that resolve to an Objective-C selector
   * should be included in the results.
   */
const CXCompletionContext_ObjCSelectorValue: CXCompletionContext = 8

/**
   * Completions for values that resolve to a C++ class type should be
   * included in the results.
   */
const CXCompletionContext_CXXClassTypeValue: CXCompletionContext = 16

/**
   * Completions for fields of the member being accessed using the dot
   * operator should be included in the results.
   */
const CXCompletionContext_DotMemberAccess: CXCompletionContext = 32

/**
   * Completions for fields of the member being accessed using the arrow
   * operator should be included in the results.
   */
const CXCompletionContext_ArrowMemberAccess: CXCompletionContext = 64

/**
   * Completions for properties of the Objective-C object being accessed
   * using the dot operator should be included in the results.
   */
const CXCompletionContext_ObjCPropertyAccess: CXCompletionContext = 128

/**
   * Completions for enum tags should be included in the results.
   */
const CXCompletionContext_EnumTag: CXCompletionContext = 256

/**
   * Completions for union tags should be included in the results.
   */
const CXCompletionContext_UnionTag: CXCompletionContext = 512

/**
   * Completions for struct tags should be included in the results.
   */
const CXCompletionContext_StructTag: CXCompletionContext = 1024

/**
   * Completions for C++ class names should be included in the results.
   */
const CXCompletionContext_ClassTag: CXCompletionContext = 2048

/**
   * Completions for C++ namespaces and namespace aliases should be
   * included in the results.
   */
const CXCompletionContext_Namespace: CXCompletionContext = 4096

/**
   * Completions for C++ nested name specifiers should be included in
   * the results.
   */
const CXCompletionContext_NestedNameSpecifier: CXCompletionContext = 8192

/**
   * Completions for Objective-C interfaces (classes) should be included
   * in the results.
   */
const CXCompletionContext_ObjCInterface: CXCompletionContext = 16384

/**
   * Completions for Objective-C protocols should be included in
   * the results.
   */
const CXCompletionContext_ObjCProtocol: CXCompletionContext = 32768

/**
   * Completions for Objective-C categories should be included in
   * the results.
   */
const CXCompletionContext_ObjCCategory: CXCompletionContext = 65536

/**
   * Completions for Objective-C instance messages should be included
   * in the results.
   */
const CXCompletionContext_ObjCInstanceMessage: CXCompletionContext = 131072

/**
   * Completions for Objective-C class messages should be included in
   * the results.
   */
const CXCompletionContext_ObjCClassMessage: CXCompletionContext = 262144

/**
   * Completions for Objective-C selector names should be included in
   * the results.
   */
const CXCompletionContext_ObjCSelectorName: CXCompletionContext = 524288

/**
   * Completions for preprocessor macro names should be included in
   * the results.
   */
const CXCompletionContext_MacroName: CXCompletionContext = 1048576

/**
   * Natural language completions should be included in the results.
   */
const CXCompletionContext_NaturalLanguage: CXCompletionContext = 2097152

/**
   * #include file completions should be included in the results.
   */
const CXCompletionContext_IncludedFile: CXCompletionContext = 4194304

/**
   * The current context is unknown, so set all contexts.
   */
const CXCompletionContext_Unknown: CXCompletionContext = 8388607

/**
 * Returns a default set of code-completion options that can be
 * passed to\c clang_codeCompleteAt().
 */
foreign func clang_defaultCodeCompleteOptions(): UInt32

/**
 * Perform code completion at a given location in a translation unit.
 *
 * This function performs code completion at a particular file, line, and
 * column within source code, providing results that suggest potential
 * code snippets based on the context of the completion. The basic model
 * for code completion is that Clang will parse a complete source file,
 * performing syntax checking up to the location where code-completion has
 * been requested. At that point, a special code-completion token is passed
 * to the parser, which recognizes this token and determines, based on the
 * current location in the C/Objective-C/C++ grammar and the state of
 * semantic analysis, what completions to provide. These completions are
 * returned via a new \c CXCodeCompleteResults structure.
 *
 * Code completion itself is meant to be triggered by the client when the
 * user types punctuation characters or whitespace, at which point the
 * code-completion location will coincide with the cursor. For example, if \c p
 * is a pointer, code-completion might be triggered after the "-" and then
 * after the ">" in \c p->. When the code-completion location is after the ">",
 * the completion results will provide, e.g., the members of the struct that
 * "p" points to. The client is responsible for placing the cursor at the
 * beginning of the token currently being typed, then filtering the results
 * based on the contents of the token. For example, when code-completing for
 * the expression \c p->get, the client should provide the location just after
 * the ">" (e.g., pointing at the "g") to this code-completion hook. Then, the
 * client can filter the results based on the current token text ("get"), only
 * showing those results that start with "get". The intent of this interface
 * is to separate the relatively high-latency acquisition of code-completion
 * results from the filtering of results on a per-character basis, which must
 * have a lower latency.
 *
 * \param TU The translation unit in which code-completion should
 * occur. The source files for this translation unit need not be
 * completely up-to-date (and the contents of those source files may
 * be overridden via \p unsaved_files). Cursors referring into the
 * translation unit may be invalidated by this invocation.
 *
 * \param complete_filename The name of the source file where code
 * completion should be performed. This filename may be any file
 * included in the translation unit.
 *
 * \param complete_line The line at which code-completion should occur.
 *
 * \param complete_column The column at which code-completion should occur.
 * Note that the column should point just after the syntactic construct that
 * initiated code completion, and not in the middle of a lexical token.
 *
 * \param unsaved_files the Files that have not yet been saved to disk
 * but may be required for parsing or code completion, including the
 * contents of those files.  The contents and name of these files (as
 * specified by CXUnsavedFile) are copied when necessary, so the
 * client only needs to guarantee their validity until the call to
 * this function returns.
 *
 * \param num_unsaved_files The number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param options Extra options that control the behavior of code
 * completion, expressed as a bitwise OR of the enumerators of the
 * CXCodeComplete_Flags enumeration. The
 * \c clang_defaultCodeCompleteOptions() function returns a default set
 * of code-completion options.
 *
 * \returns If successful, a new \c CXCodeCompleteResults structure
 * containing code-completion results, which should eventually be
 * freed with \c clang_disposeCodeCompleteResults(). If code
 * completion fails, returns NULL.
 */
foreign func clang_codeCompleteAt(TU: CPointer<CXTranslationUnitImpl>, complete_filename: CString, complete_line: UInt32, complete_column: UInt32, unsaved_files: CPointer<CXUnsavedFile>, num_unsaved_files: UInt32, options: UInt32): CPointer<CXCodeCompleteResults>

/**
 * Sort the code-completion results in case-insensitive alphabetical
 * order.
 *
 * \param Results The set of results to sort.
 * \param NumResults The number of results in \p Results.
 */
foreign func clang_sortCodeCompletionResults(Results: CPointer<CXCompletionResult>, NumResults: UInt32): Unit

/**
 * Free the given set of code-completion results.
 */
foreign func clang_disposeCodeCompleteResults(Results: CPointer<CXCodeCompleteResults>): Unit

/**
 * Determine the number of diagnostics produced prior to the
 * location where code completion was performed.
 */
foreign func clang_codeCompleteGetNumDiagnostics(Results: CPointer<CXCodeCompleteResults>): UInt32

/**
 * Retrieve a diagnostic associated with the given code completion.
 *
 * \param Results the code completion results to query.
 * \param Index the zero-based diagnostic number to retrieve.
 *
 * \returns the requested diagnostic. This diagnostic must be freed
 * via a call to \c clang_disposeDiagnostic().
 */
foreign func clang_codeCompleteGetDiagnostic(Results: CPointer<CXCodeCompleteResults>, Index: UInt32): CPointer<Unit>

/**
 * Determines what completions are appropriate for the context
 * the given code completion.
 *
 * \param Results the code completion results to query
 *
 * \returns the kinds of completions that are appropriate for use
 * along with the given code completion results.
 */
foreign func clang_codeCompleteGetContexts(Results: CPointer<CXCodeCompleteResults>): UInt64

/**
 * Returns the cursor kind for the container for the current code
 * completion context. The container is only guaranteed to be set for
 * contexts where a container exists (i.e. member accesses or Objective-C
 * message sends); if there is not a container, this function will return
 * CXCursor_InvalidCode.
 *
 * \param Results the code completion results to query
 *
 * \param IsIncomplete on return, this value will be false if Clang has complete
 * information about the container. If Clang does not have complete
 * information, this value will be true.
 *
 * \returns the container kind, or CXCursor_InvalidCode if there is not a
 * container
 */
foreign func clang_codeCompleteGetContainerKind(Results: CPointer<CXCodeCompleteResults>, IsIncomplete: CPointer<UInt32>): CXCursorKind

/**
 * Returns the USR for the container for the current code completion
 * context. If there is not a container for the current context, this
 * function will return the empty string.
 *
 * \param Results the code completion results to query
 *
 * \returns the USR for the container
 */
foreign func clang_codeCompleteGetContainerUSR(Results: CPointer<CXCodeCompleteResults>): CXString

/**
 * Returns the currently-entered selector for an Objective-C message
 * send, formatted like "initWithFoo:bar:". Only guaranteed to return a
 * non-empty string for CXCompletionContext_ObjCInstanceMessage and
 * CXCompletionContext_ObjCClassMessage.
 *
 * \param Results the code completion results to query
 *
 * \returns the selector (or partial selector) that has been entered thus far
 * for an Objective-C message send.
 */
foreign func clang_codeCompleteGetObjCSelector(Results: CPointer<CXCodeCompleteResults>): CXString

/**
 * Return a version string, suitable for showing to a user, but not
 *        intended to be parsed (the format is not guaranteed to be stable).
 */
foreign func clang_getClangVersion(): CXString

/**
 * Enable/disable crash recovery.
 *
 * \param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero
 *        value enables crash recovery, while 0 disables it.
 */
foreign func clang_toggleCrashRecovery(isEnabled: UInt32): Unit

/**
 * Visit the set of preprocessor inclusions in a translation unit.
 *   The visitor function is called with the provided data for every included
 *   file.  This does not include headers included by the PCH file (unless one
 *   is inspecting the inclusions in the PCH file itself).
 */
foreign func clang_getInclusions(tu: CPointer<CXTranslationUnitImpl>, visitor: CFunc<(CPointer<Unit>, CPointer<CXSourceLocation>, UInt32, CPointer<Unit>) -> Unit>, client_data: CPointer<Unit>): Unit

type CXEvalResultKind = Int32

const CXEval_Int: CXEvalResultKind = 1

const CXEval_Float: CXEvalResultKind = 2

const CXEval_ObjCStrLiteral: CXEvalResultKind = 3

const CXEval_StrLiteral: CXEvalResultKind = 4

const CXEval_CFStr: CXEvalResultKind = 5

const CXEval_Other: CXEvalResultKind = 6

const CXEval_UnExposed: CXEvalResultKind = 0

/**
 * If cursor is a statement declaration tries to evaluate the
 * statement and if its variable, tries to evaluate its initializer,
 * into its corresponding type.
 * If it's an expression, tries to evaluate the expression.
 */
foreign func clang_Cursor_Evaluate(C: CXCursor): CPointer<Unit>

/**
 * Returns the kind of the evaluated result.
 */
foreign func clang_EvalResult_getKind(E: CPointer<Unit>): CXEvalResultKind

/**
 * Returns the evaluation result as integer if the
 * kind is Int.
 */
foreign func clang_EvalResult_getAsInt(E: CPointer<Unit>): Int32

/**
 * Returns the evaluation result as a long long integer if the
 * kind is Int. This prevents overflows that may happen if the result is
 * returned with clang_EvalResult_getAsInt.
 */
foreign func clang_EvalResult_getAsLongLong(E: CPointer<Unit>): Int64

/**
 * Returns a non-zero value if the kind is Int and the evaluation
 * result resulted in an unsigned integer.
 */
foreign func clang_EvalResult_isUnsignedInt(E: CPointer<Unit>): UInt32

/**
 * Returns the evaluation result as an unsigned integer if
 * the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.
 */
foreign func clang_EvalResult_getAsUnsigned(E: CPointer<Unit>): UInt64

/**
 * Returns the evaluation result as double if the
 * kind is double.
 */
foreign func clang_EvalResult_getAsDouble(E: CPointer<Unit>): Float64

/**
 * Returns the evaluation result as a constant string if the
 * kind is other than Int or float. User must not free this pointer,
 * instead call clang_EvalResult_dispose on the CXEvalResult returned
 * by clang_Cursor_Evaluate.
 */
foreign func clang_EvalResult_getAsStr(E: CPointer<Unit>): CString

/**
 * Disposes the created Eval memory.
 */
foreign func clang_EvalResult_dispose(E: CPointer<Unit>): Unit

/**
 * Retrieve a remapping.
 *
 * \param path the path that contains metadata about remappings.
 *
 * \returns the requested remapping. This remapping must be freed
 * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.
 */
foreign func clang_getRemappings(path: CString): CPointer<Unit>

/**
 * Retrieve a remapping.
 *
 * \param filePaths pointer to an array of file paths containing remapping info.
 *
 * \param numFiles number of file paths.
 *
 * \returns the requested remapping. This remapping must be freed
 * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.
 */
foreign func clang_getRemappingsFromFileList(filePaths: CPointer<CString>, numFiles: UInt32): CPointer<Unit>

/**
 * Determine the number of remappings.
 */
foreign func clang_remap_getNumFiles(arg0: CPointer<Unit>): UInt32

/**
 * Get the original and the associated filename from the remapping.
 *
 * \param original If non-NULL, will be set to the original filename.
 *
 * \param transformed If non-NULL, will be set to the filename that the original
 * is associated with.
 */
foreign func clang_remap_getFilenames(arg0: CPointer<Unit>, index: UInt32, original: CPointer<CXString>, transformed: CPointer<CXString>): Unit

/**
 * Dispose the remapping.
 */
foreign func clang_remap_dispose(arg0: CPointer<Unit>): Unit

/** \defgroup CINDEX_HIGH Higher level API functions
 *
 * @{
 */
type CXVisitorResult = Int32

const CXVisit_Break: CXVisitorResult = 0

const CXVisit_Continue: CXVisitorResult = 1

type CXResult = Int32

/**
   * Function returned successfully.
   */
const CXResult_Success: CXResult = 0

/**
   * One of the parameters was invalid for the function.
   */
const CXResult_Invalid: CXResult = 1

/**
   * The function was terminated by a callback (e.g. it returned
   * CXVisit_Break)
   */
const CXResult_VisitBreak: CXResult = 2

/**
 * Find references of a declaration in a specific file.
 *
 * \param cursor pointing to a declaration or a reference of one.
 *
 * \param file to search for references.
 *
 * \param visitor callback that will receive pairs of CXCursor/CXSourceRange for
 * each reference found.
 * The CXSourceRange will point inside the file; if the reference is inside
 * a macro (and not a macro argument) the CXSourceRange will be invalid.
 *
 * \returns one of the CXResult enumerators.
 */
foreign func clang_findReferencesInFile(cursor: CXCursor, file: CPointer<Unit>, visitor: CXCursorAndRangeVisitor): CXResult

/**
 * Find #import/#include directives in a specific file.
 *
 * \param TU translation unit containing the file to query.
 *
 * \param file to search for #import/#include directives.
 *
 * \param visitor callback that will receive pairs of CXCursor/CXSourceRange for
 * each directive found.
 *
 * \returns one of the CXResult enumerators.
 */
foreign func clang_findIncludesInFile(TU: CPointer<CXTranslationUnitImpl>, file: CPointer<Unit>, visitor: CXCursorAndRangeVisitor): CXResult

foreign func clang_findReferencesInFileWithBlock(arg0: CXCursor, arg1: CPointer<Unit>, arg2: CPointer<_CXCursorAndRangeVisitorBlock>): CXResult

foreign func clang_findIncludesInFileWithBlock(arg0: CPointer<CXTranslationUnitImpl>, arg1: CPointer<Unit>, arg2: CPointer<_CXCursorAndRangeVisitorBlock>): CXResult

type CXIdxEntityKind = Int32

const CXIdxEntity_Unexposed: CXIdxEntityKind = 0

const CXIdxEntity_Typedef: CXIdxEntityKind = 1

const CXIdxEntity_Function: CXIdxEntityKind = 2

const CXIdxEntity_Variable: CXIdxEntityKind = 3

const CXIdxEntity_Field: CXIdxEntityKind = 4

const CXIdxEntity_EnumConstant: CXIdxEntityKind = 5

const CXIdxEntity_ObjCClass: CXIdxEntityKind = 6

const CXIdxEntity_ObjCProtocol: CXIdxEntityKind = 7

const CXIdxEntity_ObjCCategory: CXIdxEntityKind = 8

const CXIdxEntity_ObjCInstanceMethod: CXIdxEntityKind = 9

const CXIdxEntity_ObjCClassMethod: CXIdxEntityKind = 10

const CXIdxEntity_ObjCProperty: CXIdxEntityKind = 11

const CXIdxEntity_ObjCIvar: CXIdxEntityKind = 12

const CXIdxEntity_Enum: CXIdxEntityKind = 13

const CXIdxEntity_Struct: CXIdxEntityKind = 14

const CXIdxEntity_Union: CXIdxEntityKind = 15

const CXIdxEntity_CXXClass: CXIdxEntityKind = 16

const CXIdxEntity_CXXNamespace: CXIdxEntityKind = 17

const CXIdxEntity_CXXNamespaceAlias: CXIdxEntityKind = 18

const CXIdxEntity_CXXStaticVariable: CXIdxEntityKind = 19

const CXIdxEntity_CXXStaticMethod: CXIdxEntityKind = 20

const CXIdxEntity_CXXInstanceMethod: CXIdxEntityKind = 21

const CXIdxEntity_CXXConstructor: CXIdxEntityKind = 22

const CXIdxEntity_CXXDestructor: CXIdxEntityKind = 23

const CXIdxEntity_CXXConversionFunction: CXIdxEntityKind = 24

const CXIdxEntity_CXXTypeAlias: CXIdxEntityKind = 25

const CXIdxEntity_CXXInterface: CXIdxEntityKind = 26

const CXIdxEntity_CXXConcept: CXIdxEntityKind = 27

type CXIdxEntityLanguage = Int32

const CXIdxEntityLang_None: CXIdxEntityLanguage = 0

const CXIdxEntityLang_C: CXIdxEntityLanguage = 1

const CXIdxEntityLang_ObjC: CXIdxEntityLanguage = 2

const CXIdxEntityLang_CXX: CXIdxEntityLanguage = 3

const CXIdxEntityLang_Swift: CXIdxEntityLanguage = 4

/**
 * Extra C++ template information for an entity. This can apply to:
 * CXIdxEntity_Function
 * CXIdxEntity_CXXClass
 * CXIdxEntity_CXXStaticMethod
 * CXIdxEntity_CXXInstanceMethod
 * CXIdxEntity_CXXConstructor
 * CXIdxEntity_CXXConversionFunction
 * CXIdxEntity_CXXTypeAlias
 */
type CXIdxEntityCXXTemplateKind = Int32

const CXIdxEntity_NonTemplate: CXIdxEntityCXXTemplateKind = 0

const CXIdxEntity_Template: CXIdxEntityCXXTemplateKind = 1

const CXIdxEntity_TemplatePartialSpecialization: CXIdxEntityCXXTemplateKind = 2

const CXIdxEntity_TemplateSpecialization: CXIdxEntityCXXTemplateKind = 3

type CXIdxAttrKind = Int32

const CXIdxAttr_Unexposed: CXIdxAttrKind = 0

const CXIdxAttr_IBAction: CXIdxAttrKind = 1

const CXIdxAttr_IBOutlet: CXIdxAttrKind = 2

const CXIdxAttr_IBOutletCollection: CXIdxAttrKind = 3

type CXIdxDeclInfoFlags = Int32

const CXIdxDeclFlag_Skipped: CXIdxDeclInfoFlags = 1

type CXIdxObjCContainerKind = Int32

const CXIdxObjCContainer_ForwardRef: CXIdxObjCContainerKind = 0

const CXIdxObjCContainer_Interface: CXIdxObjCContainerKind = 1

const CXIdxObjCContainer_Implementation: CXIdxObjCContainerKind = 2

/**
 * Data for IndexerCallbacks#indexEntityReference.
 *
 * This may be deprecated in a future version as this duplicates
 * the \c CXSymbolRole_Implicit bit in \c CXSymbolRole.
 */
type CXIdxEntityRefKind = Int32

/**
   * The entity is referenced directly in user's code.
   */
const CXIdxEntityRef_Direct: CXIdxEntityRefKind = 1

/**
   * An implicit reference, e.g. a reference of an Objective-C method
   * via the dot syntax.
   */
const CXIdxEntityRef_Implicit: CXIdxEntityRefKind = 2

/**
 * Roles that are attributed to symbol occurrences.
 *
 * Internal: this currently mirrors low 9 bits of clang::index::SymbolRole with
 * higher bits zeroed. These high bits may be exposed in the future.
 */
type CXSymbolRole = Int32

const CXSymbolRole_None: CXSymbolRole = 0

const CXSymbolRole_Declaration: CXSymbolRole = 1

const CXSymbolRole_Definition: CXSymbolRole = 2

const CXSymbolRole_Reference: CXSymbolRole = 4

const CXSymbolRole_Read: CXSymbolRole = 8

const CXSymbolRole_Write: CXSymbolRole = 16

const CXSymbolRole_Call: CXSymbolRole = 32

const CXSymbolRole_Dynamic: CXSymbolRole = 64

const CXSymbolRole_AddressOf: CXSymbolRole = 128

const CXSymbolRole_Implicit: CXSymbolRole = 256

foreign func clang_index_isEntityObjCContainerKind(arg0: CXIdxEntityKind): Int32

foreign func clang_index_getObjCContainerDeclInfo(arg0: CPointer<CXIdxDeclInfo>): CPointer<CXIdxObjCContainerDeclInfo>

foreign func clang_index_getObjCInterfaceDeclInfo(arg0: CPointer<CXIdxDeclInfo>): CPointer<CXIdxObjCInterfaceDeclInfo>

foreign func clang_index_getObjCCategoryDeclInfo(arg0: CPointer<CXIdxDeclInfo>): CPointer<CXIdxObjCCategoryDeclInfo>

foreign func clang_index_getObjCProtocolRefListInfo(arg0: CPointer<CXIdxDeclInfo>): CPointer<CXIdxObjCProtocolRefListInfo>

foreign func clang_index_getObjCPropertyDeclInfo(arg0: CPointer<CXIdxDeclInfo>): CPointer<CXIdxObjCPropertyDeclInfo>

foreign func clang_index_getIBOutletCollectionAttrInfo(arg0: CPointer<CXIdxAttrInfo>): CPointer<CXIdxIBOutletCollectionAttrInfo>

foreign func clang_index_getCXXClassDeclInfo(arg0: CPointer<CXIdxDeclInfo>): CPointer<CXIdxCXXClassDeclInfo>

/**
 * For retrieving a custom CXIdxClientContainer attached to a
 * container.
 */
foreign func clang_index_getClientContainer(arg0: CPointer<CXIdxContainerInfo>): CPointer<Unit>

/**
 * For setting a custom CXIdxClientContainer attached to a
 * container.
 */
foreign func clang_index_setClientContainer(arg0: CPointer<CXIdxContainerInfo>, arg1: CPointer<Unit>): Unit

/**
 * For retrieving a custom CXIdxClientEntity attached to an entity.
 */
foreign func clang_index_getClientEntity(arg0: CPointer<CXIdxEntityInfo>): CPointer<Unit>

/**
 * For setting a custom CXIdxClientEntity attached to an entity.
 */
foreign func clang_index_setClientEntity(arg0: CPointer<CXIdxEntityInfo>, arg1: CPointer<Unit>): Unit

/**
 * An indexing action/session, to be applied to one or multiple
 * translation units.
 *
 * \param CIdx The index object with which the index action will be associated.
 */
foreign func clang_IndexAction_create(CIdx: CPointer<Unit>): CPointer<Unit>

/**
 * Destroy the given index action.
 *
 * The index action must not be destroyed until all of the translation units
 * created within that index action have been destroyed.
 */
foreign func clang_IndexAction_dispose(arg0: CPointer<Unit>): Unit

type CXIndexOptFlags = Int32

/**
   * Used to indicate that no special indexing options are needed.
   */
const CXIndexOpt_None: CXIndexOptFlags = 0

/**
   * Used to indicate that IndexerCallbacks#indexEntityReference should
   * be invoked for only one reference of an entity per source file that does
   * not also include a declaration/definition of the entity.
   */
const CXIndexOpt_SuppressRedundantRefs: CXIndexOptFlags = 1

/**
   * Function-local symbols should be indexed. If this is not set
   * function-local symbols will be ignored.
   */
const CXIndexOpt_IndexFunctionLocalSymbols: CXIndexOptFlags = 2

/**
   * Implicit function/class template instantiations should be indexed.
   * If this is not set, implicit instantiations will be ignored.
   */
const CXIndexOpt_IndexImplicitTemplateInstantiations: CXIndexOptFlags = 4

/**
   * Suppress all compiler warnings when parsing for indexing.
   */
const CXIndexOpt_SuppressWarnings: CXIndexOptFlags = 8

/**
   * Skip a function/method body that was already parsed during an
   * indexing session associated with a \c CXIndexAction object.
   * Bodies in system headers are always skipped.
   */
const CXIndexOpt_SkipParsedBodiesInSession: CXIndexOptFlags = 16

/**
 * Index the given source file and the translation unit corresponding
 * to that file via callbacks implemented through #IndexerCallbacks.
 *
 * \param client_data pointer data supplied by the client, which will
 * be passed to the invoked callbacks.
 *
 * \param index_callbacks Pointer to indexing callbacks that the client
 * implements.
 *
 * \param index_callbacks_size Size of #IndexerCallbacks structure that gets
 * passed in index_callbacks.
 *
 * \param index_options A bitmask of options that affects how indexing is
 * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.
 *
 * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be
 * reused after indexing is finished. Set to \c NULL if you do not require it.
 *
 * \returns 0 on success or if there were errors from which the compiler could
 * recover.  If there is a failure from which there is no recovery, returns
 * a non-zero \c CXErrorCode.
 *
 * The rest of the parameters are the same as #clang_parseTranslationUnit.
 */
foreign func clang_indexSourceFile(arg0: CPointer<Unit>, client_data: CPointer<Unit>, index_callbacks: CPointer<IndexerCallbacks>, index_callbacks_size: UInt32, index_options: UInt32, source_filename: CString, command_line_args: CPointer<CString>, num_command_line_args: Int32, unsaved_files: CPointer<CXUnsavedFile>, num_unsaved_files: UInt32, out_TU: CPointer<CPointer<CXTranslationUnitImpl>>, TU_options: UInt32): Int32

/**
 * Same as clang_indexSourceFile but requires a full command line
 * for \c command_line_args including argv[0]. This is useful if the standard
 * library paths are relative to the binary.
 */
foreign func clang_indexSourceFileFullArgv(arg0: CPointer<Unit>, client_data: CPointer<Unit>, index_callbacks: CPointer<IndexerCallbacks>, index_callbacks_size: UInt32, index_options: UInt32, source_filename: CString, command_line_args: CPointer<CString>, num_command_line_args: Int32, unsaved_files: CPointer<CXUnsavedFile>, num_unsaved_files: UInt32, out_TU: CPointer<CPointer<CXTranslationUnitImpl>>, TU_options: UInt32): Int32

/**
 * Index the given translation unit via callbacks implemented through
 * #IndexerCallbacks.
 *
 * The order of callback invocations is not guaranteed to be the same as
 * when indexing a source file. The high level order will be:
 *
 *   -Preprocessor callbacks invocations
 *   -Declaration/reference callbacks invocations
 *   -Diagnostic callback invocations
 *
 * The parameters are the same as #clang_indexSourceFile.
 *
 * \returns If there is a failure from which there is no recovery, returns
 * non-zero, otherwise returns 0.
 */
foreign func clang_indexTranslationUnit(arg0: CPointer<Unit>, client_data: CPointer<Unit>, index_callbacks: CPointer<IndexerCallbacks>, index_callbacks_size: UInt32, index_options: UInt32, arg5: CPointer<CXTranslationUnitImpl>): Int32

/**
 * Retrieve the CXIdxFile, file, line, column, and offset represented by
 * the given CXIdxLoc.
 *
 * If the location refers into a macro expansion, retrieves the
 * location of the macro expansion and if it refers into a macro argument
 * retrieves the location of the argument.
 */
foreign func clang_indexLoc_getFileLocation(loc: CXIdxLoc, indexFile: CPointer<CPointer<Unit>>, file: CPointer<CPointer<Unit>>, line: CPointer<UInt32>, column: CPointer<UInt32>, offset: CPointer<UInt32>): Unit

/**
 * Retrieve the CXSourceLocation represented by the given CXIdxLoc.
 */
foreign func clang_indexLoc_getCXSourceLocation(loc: CXIdxLoc): CXSourceLocation

/**
 * Visit the fields of a particular type.
 *
 * This function visits all the direct fields of the given cursor,
 * invoking the given \p visitor function with the cursors of each
 * visited field. The traversal may be ended prematurely, if
 * the visitor returns \c CXFieldVisit_Break.
 *
 * \param T the record type whose field may be visited.
 *
 * \param visitor the visitor function that will be invoked for each
 * field of \p T.
 *
 * \param client_data pointer data supplied by the client, which will
 * be passed to the visitor each time it is invoked.
 *
 * \returns a non-zero value if the traversal was terminated
 * prematurely by the visitor returning \c CXFieldVisit_Break.
 */
foreign func clang_Type_visitFields(T: CXType, visitor: CFunc<(CXCursor, CPointer<Unit>) -> CXVisitorResult>, client_data: CPointer<Unit>): UInt32

/**
 * Describes the kind of binary operators.
 */
type CXBinaryOperatorKind = Int32

/** This value describes cursors which are not binary operators. */
const CXBinaryOperator_Invalid: CXBinaryOperatorKind = 0

/** C++ Pointer - to - member operator. */
const CXBinaryOperator_PtrMemD: CXBinaryOperatorKind = 1

/** C++ Pointer - to - member operator. */
const CXBinaryOperator_PtrMemI: CXBinaryOperatorKind = 2

/** Multiplication operator. */
const CXBinaryOperator_Mul: CXBinaryOperatorKind = 3

/** Division operator. */
const CXBinaryOperator_Div: CXBinaryOperatorKind = 4

/** Remainder operator. */
const CXBinaryOperator_Rem: CXBinaryOperatorKind = 5

/** Addition operator. */
const CXBinaryOperator_Add: CXBinaryOperatorKind = 6

/** Subtraction operator. */
const CXBinaryOperator_Sub: CXBinaryOperatorKind = 7

/** Bitwise shift left operator. */
const CXBinaryOperator_Shl: CXBinaryOperatorKind = 8

/** Bitwise shift right operator. */
const CXBinaryOperator_Shr: CXBinaryOperatorKind = 9

/** C++ three-way comparison (spaceship) operator. */
const CXBinaryOperator_Cmp: CXBinaryOperatorKind = 10

/** Less than operator. */
const CXBinaryOperator_LT: CXBinaryOperatorKind = 11

/** Greater than operator. */
const CXBinaryOperator_GT: CXBinaryOperatorKind = 12

/** Less or equal operator. */
const CXBinaryOperator_LE: CXBinaryOperatorKind = 13

/** Greater or equal operator. */
const CXBinaryOperator_GE: CXBinaryOperatorKind = 14

/** Equal operator. */
const CXBinaryOperator_EQ: CXBinaryOperatorKind = 15

/** Not equal operator. */
const CXBinaryOperator_NE: CXBinaryOperatorKind = 16

/** Bitwise AND operator. */
const CXBinaryOperator_And: CXBinaryOperatorKind = 17

/** Bitwise XOR operator. */
const CXBinaryOperator_Xor: CXBinaryOperatorKind = 18

/** Bitwise OR operator. */
const CXBinaryOperator_Or: CXBinaryOperatorKind = 19

/** Logical AND operator. */
const CXBinaryOperator_LAnd: CXBinaryOperatorKind = 20

/** Logical OR operator. */
const CXBinaryOperator_LOr: CXBinaryOperatorKind = 21

/** Assignment operator. */
const CXBinaryOperator_Assign: CXBinaryOperatorKind = 22

/** Multiplication assignment operator. */
const CXBinaryOperator_MulAssign: CXBinaryOperatorKind = 23

/** Division assignment operator. */
const CXBinaryOperator_DivAssign: CXBinaryOperatorKind = 24

/** Remainder assignment operator. */
const CXBinaryOperator_RemAssign: CXBinaryOperatorKind = 25

/** Addition assignment operator. */
const CXBinaryOperator_AddAssign: CXBinaryOperatorKind = 26

/** Subtraction assignment operator. */
const CXBinaryOperator_SubAssign: CXBinaryOperatorKind = 27

/** Bitwise shift left assignment operator. */
const CXBinaryOperator_ShlAssign: CXBinaryOperatorKind = 28

/** Bitwise shift right assignment operator. */
const CXBinaryOperator_ShrAssign: CXBinaryOperatorKind = 29

/** Bitwise AND assignment operator. */
const CXBinaryOperator_AndAssign: CXBinaryOperatorKind = 30

/** Bitwise XOR assignment operator. */
const CXBinaryOperator_XorAssign: CXBinaryOperatorKind = 31

/** Bitwise OR assignment operator. */
const CXBinaryOperator_OrAssign: CXBinaryOperatorKind = 32

/** Comma operator. */
const CXBinaryOperator_Comma: CXBinaryOperatorKind = 33

/**
 * Retrieve the spelling of a given CXBinaryOperatorKind.
 */
foreign func clang_getBinaryOperatorKindSpelling(kind: CXBinaryOperatorKind): CXString

/**
 * Retrieve the binary operator kind of this cursor.
 *
 * If this cursor is not a binary operator then returns Invalid.
 */
foreign func clang_getCursorBinaryOperatorKind(cursor: CXCursor): CXBinaryOperatorKind

/**
 * Describes the kind of unary operators.
 */
type CXUnaryOperatorKind = Int32

/** This value describes cursors which are not unary operators. */
const CXUnaryOperator_Invalid: CXUnaryOperatorKind = 0

/** Postfix increment operator. */
const CXUnaryOperator_PostInc: CXUnaryOperatorKind = 1

/** Postfix decrement operator. */
const CXUnaryOperator_PostDec: CXUnaryOperatorKind = 2

/** Prefix increment operator. */
const CXUnaryOperator_PreInc: CXUnaryOperatorKind = 3

/** Prefix decrement operator. */
const CXUnaryOperator_PreDec: CXUnaryOperatorKind = 4

/** Address of operator. */
const CXUnaryOperator_AddrOf: CXUnaryOperatorKind = 5

/** Dereference operator. */
const CXUnaryOperator_Deref: CXUnaryOperatorKind = 6

/** Plus operator. */
const CXUnaryOperator_Plus: CXUnaryOperatorKind = 7

/** Minus operator. */
const CXUnaryOperator_Minus: CXUnaryOperatorKind = 8

/** Not operator. */
const CXUnaryOperator_Not: CXUnaryOperatorKind = 9

/** LNot operator. */
const CXUnaryOperator_LNot: CXUnaryOperatorKind = 10

/** "__real expr" operator. */
const CXUnaryOperator_Real: CXUnaryOperatorKind = 11

/** "__imag expr" operator. */
const CXUnaryOperator_Imag: CXUnaryOperatorKind = 12

/** __extension__ marker operator. */
const CXUnaryOperator_Extension: CXUnaryOperatorKind = 13

/** C++ co_await operator. */
const CXUnaryOperator_Coawait: CXUnaryOperatorKind = 14

/**
 * Retrieve the spelling of a given CXUnaryOperatorKind.
 */
foreign func clang_getUnaryOperatorKindSpelling(kind: CXUnaryOperatorKind): CXString

/**
 * Retrieve the unary operator kind of this cursor.
 *
 * If this cursor is not a unary operator then returns Invalid.
 */
foreign func clang_getCursorUnaryOperatorKind(cursor: CXCursor): CXUnaryOperatorKind

/**
 * A character string.
 *
 * The \c CXString type is used to return strings from the interface when
 * the ownership of that string might differ from one call to the next.
 * Use \c clang_getCString() to retrieve the string data and, once finished
 * with the string data, call \c clang_disposeString() to free the string.
 */
@C
struct CXString {
    var data: CPointer<Unit> = CPointer()
    var private_flags: UInt32 = 0
}

@C
struct CXStringSet {
    var Strings: CPointer<CXString> = CPointer()
    var Count: UInt32 = 0
}

@C
struct CXVirtualFileOverlayImpl {
}

@C
struct CXModuleMapDescriptorImpl {
}

/**
 * Uniquely identifies a CXFile, that refers to the same underlying file,
 * across an indexing session.
 */
@C
struct CXFileUniqueID {
    var data: VArray<UInt64, $3> = VArray<UInt64, $3>(repeat: 0)
}

/**
 * Identifies a specific source location within a translation
 * unit.
 *
 * Use clang_getExpansionLocation() or clang_getSpellingLocation()
 * to map a source location to a particular file, line, and column.
 */
@C
struct CXSourceLocation {
    var ptr_data: VArray<CPointer<Unit>, $2> = VArray<CPointer<Unit>, $2>(repeat: CPointer())
    var int_data: UInt32 = 0
}

/**
 * Identifies a half-open character range in the source code.
 *
 * Use clang_getRangeStart() and clang_getRangeEnd() to retrieve the
 * starting and end locations from a source range, respectively.
 */
@C
struct CXSourceRange {
    var ptr_data: VArray<CPointer<Unit>, $2> = VArray<CPointer<Unit>, $2>(repeat: CPointer())
    var begin_int_data: UInt32 = 0
    var end_int_data: UInt32 = 0
}

/**
 * Identifies an array of ranges.
 */
@C
struct CXSourceRangeList {
    /** The number of ranges in the \c ranges array. */
    var count: UInt32 = 0
    /**
   * An array of \c CXSourceRanges.
   */
    var ranges: CPointer<CXSourceRange> = CPointer()
}

@C
struct CXTargetInfoImpl {
}

@C
struct CXTranslationUnitImpl {
}

/**
 * Provides the contents of a file that has not yet been saved to disk.
 *
 * Each CXUnsavedFile instance provides the name of a file on the
 * system along with the current contents of that file that have not
 * yet been saved to disk.
 */
@C
struct CXUnsavedFile {
    /**
   * The file whose contents have not yet been saved.
   *
   * This file must already exist in the file system.
   */
    var Filename: CString = CString(CPointer<UInt8>())
    /**
   * A buffer containing the unsaved contents of this file.
   */
    var Contents: CString = CString(CPointer<UInt8>())
    /**
   * The length of the unsaved contents of this buffer.
   */
    var Length: UInt64 = 0
}

/**
 * Describes a version number of the form major.minor.subminor.
 */
@C
struct CXVersion {
    /**
   * The major version number, e.g., the '10' in '10.7.3'. A negative
   * value indicates that there is no version number at all.
   */
    var Major: Int32 = 0
    /**
   * The minor version number, e.g., the '7' in '10.7.3'. This value
   * will be negative if no minor version number was provided, e.g., for
   * version '10'.
   */
    var Minor: Int32 = 0
    /**
   * The subminor version number, e.g., the '3' in '10.7.3'. This value
   * will be negative if no minor or subminor version number was provided,
   * e.g., in version '10' or '10.7'.
   */
    var Subminor: Int32 = 0
}

/**
 * Index initialization options.
 *
 * 0 is the default value of each member of this struct except for Size.
 * Initialize the struct in one of the following three ways to avoid adapting
 * code each time a new member is added to it:
 * \code
 * CXIndexOptions Opts;
 * memset(&Opts, 0, sizeof(Opts));
 * Opts.Size = sizeof(CXIndexOptions);
 * \endcode
 * or explicitly initialize the first data member and zero-initialize the rest:
 * \code
 * CXIndexOptions Opts = { sizeof(CXIndexOptions) };
 * \endcode
 * or to prevent the -Wmissing-field-initializers warning for the above version:
 * \code
 * CXIndexOptions Opts{};
 * Opts.Size = sizeof(CXIndexOptions);
 * \endcode
 */
@C
struct CXIndexOptions {
    /**
   * The size of struct CXIndexOptions used for option versioning.
   *
   * Always initialize this member to sizeof(CXIndexOptions), or assign
   * sizeof(CXIndexOptions) to it right after creating a CXIndexOptions object.
   */
    var Size: UInt32 = 0
    /**
   * A CXChoice enumerator that specifies the indexing priority policy.
   * \sa CXGlobalOpt_ThreadBackgroundPriorityForIndexing
   */
    var ThreadBackgroundPriorityForIndexing: UInt8 = 0
    /**
   * A CXChoice enumerator that specifies the editing priority policy.
   * \sa CXGlobalOpt_ThreadBackgroundPriorityForEditing
   */
    var ThreadBackgroundPriorityForEditing: UInt8 = 0
    // 位域
    // ExcludeDeclarationsFromPCH unsigned int : 1
    // DisplayDiagnostics unsigned int : 1
    // StorePreamblesInMemory unsigned int : 1
    // unnamed unsigned int : 13
    var bitfields: VArray<UInt8, $2> = VArray<UInt8, $2>(repeat: 0)
    /**
   * The path to a directory, in which to store temporary PCH files. If null or
   * empty, the default system temporary directory is used. These PCH files are
   * deleted on clean exit but stay on disk if the program crashes or is killed.
   *
   * This option is ignored if \a StorePreamblesInMemory is non-zero.
   *
   * Libclang does not create the directory at the specified path in the file
   * system. Therefore it must exist, or storing PCH files will fail.
   */
    var PreambleStoragePath: CString = CString(CPointer<UInt8>())
    /**
   * Specifies a path which will contain log files for certain libclang
   * invocations. A null value implies that libclang invocations are not logged.
   */
    var InvocationEmissionPath: CString = CString(CPointer<UInt8>())
}

@C
struct CXTUResourceUsageEntry {
    var kind: CXTUResourceUsageKind = 0
    var amount: UInt64 = 0
}

/**
 * The memory usage of a CXTranslationUnit, broken into categories.
 */
@C
struct CXTUResourceUsage {
    var data: CPointer<Unit> = CPointer()
    var numEntries: UInt32 = 0
    var entries: CPointer<CXTUResourceUsageEntry> = CPointer()
}

/**
 * A cursor representing some element in the abstract syntax tree for
 * a translation unit.
 *
 * The cursor abstraction unifies the different kinds of entities in a
 * program--declaration, statements, expressions, references to declarations,
 * etc.--under a single "cursor" abstraction with a common set of operations.
 * Common operation for a cursor include: getting the physical location in
 * a source file where the cursor points, getting the name associated with a
 * cursor, and retrieving cursors for any child nodes of a particular cursor.
 *
 * Cursors can be produced in two specific ways.
 * clang_getTranslationUnitCursor() produces a cursor for a translation unit,
 * from which one can use clang_visitChildren() to explore the rest of the
 * translation unit. clang_getCursor() maps from a physical source location
 * to the entity that resides at that location, allowing one to map from the
 * source code into the AST.
 */
@C
struct CXCursor {
    var kind: CXCursorKind = 0
    var xdata: Int32 = 0
    var data: VArray<CPointer<Unit>, $3> = VArray<CPointer<Unit>, $3>(repeat: CPointer())
}

/**
 * Describes the availability of a given entity on a particular platform, e.g.,
 * a particular class might only be available on Mac OS 10.7 or newer.
 */
@C
struct CXPlatformAvailability {
    /**
   * A string that describes the platform for which this structure
   * provides availability information.
   *
   * Possible values are "ios" or "macos".
   */
    var Platform: CXString = CXString()
    /**
   * The version number in which this entity was introduced.
   */
    var Introduced: CXVersion = CXVersion()
    /**
   * The version number in which this entity was deprecated (but is
   * still available).
   */
    var Deprecated: CXVersion = CXVersion()
    /**
   * The version number in which this entity was obsoleted, and therefore
   * is no longer available.
   */
    var Obsoleted: CXVersion = CXVersion()
    /**
   * Whether the entity is unconditionally unavailable on this platform.
   */
    var Unavailable: Int32 = 0
    /**
   * An optional message to provide to a user of this API, e.g., to
   * suggest replacement APIs.
   */
    var Message: CXString = CXString()
}

@C
struct CXCursorSetImpl {
}

/**
 * The type of an element in the abstract syntax tree.
 *
 */
@C
struct CXType {
    var kind: CXTypeKind = 0
    var data: VArray<CPointer<Unit>, $2> = VArray<CPointer<Unit>, $2>(repeat: CPointer())
}

@C
struct _CXChildVisitResult {
}

/**
 * Describes a single preprocessing token.
 */
@C
struct CXToken {
    var int_data: VArray<UInt32, $4> = VArray<UInt32, $4>(repeat: 0)
    var ptr_data: CPointer<Unit> = CPointer()
}

/**
 * A single result of code completion.
 */
@C
struct CXCompletionResult {
    /**
   * The kind of entity that this completion refers to.
   *
   * The cursor kind will be a macro, keyword, or a declaration (one of the
   * *Decl cursor kinds), describing the entity that the completion is
   * referring to.
   *
   * \todo In the future, we would like to provide a full cursor, to allow
   * the client to extract additional information from declaration.
   */
    var CursorKind: CXCursorKind = 0
    /**
   * The code-completion string that describes how to insert this
   * code-completion result into the editing buffer.
   */
    var CompletionString: CPointer<Unit> = CPointer()
}

/**
 * Contains the results of code-completion.
 *
 * This data structure contains the results of code completion, as
 * produced by \c clang_codeCompleteAt(). Its contents must be freed by
 * \c clang_disposeCodeCompleteResults.
 */
@C
struct CXCodeCompleteResults {
    /**
   * The code-completion results.
   */
    var Results: CPointer<CXCompletionResult> = CPointer()
    /**
   * The number of code-completion results stored in the
   * \c Results array.
   */
    var NumResults: UInt32 = 0
}

@C
struct CXCursorAndRangeVisitor {
    var context: CPointer<Unit> = CPointer()
    var visit: CFunc<(CPointer<Unit>, CXCursor, CXSourceRange) -> CXVisitorResult> = CFunc<(CPointer<Unit>, CXCursor, CXSourceRange) -> CXVisitorResult>(CPointer<Int8>())
}

@C
struct _CXCursorAndRangeVisitorBlock {
}

/**
 * Source location passed to index callbacks.
 */
@C
struct CXIdxLoc {
    var ptr_data: VArray<CPointer<Unit>, $2> = VArray<CPointer<Unit>, $2>(repeat: CPointer())
    var int_data: UInt32 = 0
}

/**
 * Data for ppIncludedFile callback.
 */
@C
struct CXIdxIncludedFileInfo {
    /**
   * Location of '#' in the \#include/\#import directive.
   */
    var hashLoc: CXIdxLoc = CXIdxLoc()
    /**
   * Filename as written in the \#include/\#import directive.
   */
    var filename: CString = CString(CPointer<UInt8>())
    /**
   * The actual file that the \#include/\#import directive resolved to.
   */
    var file: CPointer<Unit> = CPointer()
    var isImport: Int32 = 0
    var isAngled: Int32 = 0
    /**
   * Non-zero if the directive was automatically turned into a module
   * import.
   */
    var isModuleImport: Int32 = 0
}

/**
 * Data for IndexerCallbacks#importedASTFile.
 */
@C
struct CXIdxImportedASTFileInfo {
    /**
   * Top level AST file containing the imported PCH, module or submodule.
   */
    var file: CPointer<Unit> = CPointer()
    /**
   * The imported module or NULL if the AST file is a PCH.
   */
    var module: CPointer<Unit> = CPointer()
    /**
   * Location where the file is imported. Applicable only for modules.
   */
    var loc: CXIdxLoc = CXIdxLoc()
    /**
   * Non-zero if an inclusion directive was automatically turned into
   * a module import. Applicable only for modules.
   */
    var isImplicit: Int32 = 0
}

@C
struct CXIdxAttrInfo {
    var kind: CXIdxAttrKind = 0
    var cursor: CXCursor = CXCursor()
    var loc: CXIdxLoc = CXIdxLoc()
}

@C
struct CXIdxEntityInfo {
    var kind: CXIdxEntityKind = 0
    var templateKind: CXIdxEntityCXXTemplateKind = 0
    var lang: CXIdxEntityLanguage = 0
    var name: CString = CString(CPointer<UInt8>())
    var USR: CString = CString(CPointer<UInt8>())
    var cursor: CXCursor = CXCursor()
    var attributes: CPointer<CPointer<CXIdxAttrInfo>> = CPointer()
    var numAttributes: UInt32 = 0
}

@C
struct CXIdxContainerInfo {
    var cursor: CXCursor = CXCursor()
}

@C
struct CXIdxIBOutletCollectionAttrInfo {
    var attrInfo: CPointer<CXIdxAttrInfo> = CPointer()
    var objcClass: CPointer<CXIdxEntityInfo> = CPointer()
    var classCursor: CXCursor = CXCursor()
    var classLoc: CXIdxLoc = CXIdxLoc()
}

@C
struct CXIdxDeclInfo {
    var entityInfo: CPointer<CXIdxEntityInfo> = CPointer()
    var cursor: CXCursor = CXCursor()
    var loc: CXIdxLoc = CXIdxLoc()
    var semanticContainer: CPointer<CXIdxContainerInfo> = CPointer()
    /**
   * Generally same as #semanticContainer but can be different in
   * cases like out-of-line C++ member functions.
   */
    var lexicalContainer: CPointer<CXIdxContainerInfo> = CPointer()
    var isRedeclaration: Int32 = 0
    var isDefinition: Int32 = 0
    var isContainer: Int32 = 0
    var declAsContainer: CPointer<CXIdxContainerInfo> = CPointer()
    /**
   * Whether the declaration exists in code or was created implicitly
   * by the compiler, e.g. implicit Objective-C methods for properties.
   */
    var isImplicit: Int32 = 0
    var attributes: CPointer<CPointer<CXIdxAttrInfo>> = CPointer()
    var numAttributes: UInt32 = 0
    var flags: UInt32 = 0
}

@C
struct CXIdxObjCContainerDeclInfo {
    var declInfo: CPointer<CXIdxDeclInfo> = CPointer()
    var kind: CXIdxObjCContainerKind = 0
}

@C
struct CXIdxBaseClassInfo {
    var base: CPointer<CXIdxEntityInfo> = CPointer()
    var cursor: CXCursor = CXCursor()
    var loc: CXIdxLoc = CXIdxLoc()
}

@C
struct CXIdxObjCProtocolRefInfo {
    var protocol: CPointer<CXIdxEntityInfo> = CPointer()
    var cursor: CXCursor = CXCursor()
    var loc: CXIdxLoc = CXIdxLoc()
}

@C
struct CXIdxObjCProtocolRefListInfo {
    var protocols: CPointer<CPointer<CXIdxObjCProtocolRefInfo>> = CPointer()
    var numProtocols: UInt32 = 0
}

@C
struct CXIdxObjCInterfaceDeclInfo {
    var containerInfo: CPointer<CXIdxObjCContainerDeclInfo> = CPointer()
    var superInfo: CPointer<CXIdxBaseClassInfo> = CPointer()
    var protocols: CPointer<CXIdxObjCProtocolRefListInfo> = CPointer()
}

@C
struct CXIdxObjCCategoryDeclInfo {
    var containerInfo: CPointer<CXIdxObjCContainerDeclInfo> = CPointer()
    var objcClass: CPointer<CXIdxEntityInfo> = CPointer()
    var classCursor: CXCursor = CXCursor()
    var classLoc: CXIdxLoc = CXIdxLoc()
    var protocols: CPointer<CXIdxObjCProtocolRefListInfo> = CPointer()
}

@C
struct CXIdxObjCPropertyDeclInfo {
    var declInfo: CPointer<CXIdxDeclInfo> = CPointer()
    var getter: CPointer<CXIdxEntityInfo> = CPointer()
    var setter: CPointer<CXIdxEntityInfo> = CPointer()
}

@C
struct CXIdxCXXClassDeclInfo {
    var declInfo: CPointer<CXIdxDeclInfo> = CPointer()
    var bases: CPointer<CPointer<CXIdxBaseClassInfo>> = CPointer()
    var numBases: UInt32 = 0
}

/**
 * Data for IndexerCallbacks#indexEntityReference.
 */
@C
struct CXIdxEntityRefInfo {
    var kind: CXIdxEntityRefKind = 0
    /**
   * Reference cursor.
   */
    var cursor: CXCursor = CXCursor()
    var loc: CXIdxLoc = CXIdxLoc()
    /**
   * The entity that gets referenced.
   */
    var referencedEntity: CPointer<CXIdxEntityInfo> = CPointer()
    /**
   * Immediate "parent" of the reference. For example:
   *
   * \code
   * Foo *var;
   * \endcode
   *
   * The parent of reference of type 'Foo' is the variable 'var'.
   * For references inside statement bodies of functions/methods,
   * the parentEntity will be the function/method.
   */
    var parentEntity: CPointer<CXIdxEntityInfo> = CPointer()
    /**
   * Lexical container context of the reference.
   */
    var container: CPointer<CXIdxContainerInfo> = CPointer()
    /**
   * Sets of symbol roles of the reference.
   */
    var role: CXSymbolRole = 0
}

/**
 * A group of callbacks used by #clang_indexSourceFile and
 * #clang_indexTranslationUnit.
 */
@C
struct IndexerCallbacks {
    /**
   * Called periodically to check whether indexing should be aborted.
   * Should return 0 to continue, and non-zero to abort.
   */
    var abortQuery: CFunc<(CPointer<Unit>, CPointer<Unit>) -> Int32> = CFunc<(CPointer<Unit>, CPointer<Unit>) -> Int32>(CPointer<Int8>())
    /**
   * Called at the end of indexing; passes the complete diagnostic set.
   */
    var diagnostic: CFunc<(CPointer<Unit>, CPointer<Unit>, CPointer<Unit>) -> Unit> = CFunc<(CPointer<Unit>, CPointer<Unit>, CPointer<Unit>) -> Unit>(CPointer<Int8>())
    var enteredMainFile: CFunc<(CPointer<Unit>, CPointer<Unit>, CPointer<Unit>) -> CPointer<Unit>> = CFunc<(CPointer<Unit>, CPointer<Unit>, CPointer<Unit>) -> CPointer<Unit>>(CPointer<Int8>())
    /**
   * Called when a file gets \#included/\#imported.
   */
    var ppIncludedFile: CFunc<(CPointer<Unit>, CPointer<CXIdxIncludedFileInfo>) -> CPointer<Unit>> = CFunc<(CPointer<Unit>, CPointer<CXIdxIncludedFileInfo>) -> CPointer<Unit>>(CPointer<Int8>())
    /**
   * Called when a AST file (PCH or module) gets imported.
   *
   * AST files will not get indexed (there will not be callbacks to index all
   * the entities in an AST file). The recommended action is that, if the AST
   * file is not already indexed, to initiate a new indexing job specific to
   * the AST file.
   */
    var importedASTFile: CFunc<(CPointer<Unit>, CPointer<CXIdxImportedASTFileInfo>) -> CPointer<Unit>> = CFunc<(CPointer<Unit>, CPointer<CXIdxImportedASTFileInfo>) -> CPointer<Unit>>(CPointer<Int8>())
    /**
   * Called at the beginning of indexing a translation unit.
   */
    var startedTranslationUnit: CFunc<(CPointer<Unit>, CPointer<Unit>) -> CPointer<Unit>> = CFunc<(CPointer<Unit>, CPointer<Unit>) -> CPointer<Unit>>(CPointer<Int8>())
    var indexDeclaration: CFunc<(CPointer<Unit>, CPointer<CXIdxDeclInfo>) -> Unit> = CFunc<(CPointer<Unit>, CPointer<CXIdxDeclInfo>) -> Unit>(CPointer<Int8>())
    /**
   * Called to index a reference of an entity.
   */
    var indexEntityReference: CFunc<(CPointer<Unit>, CPointer<CXIdxEntityRefInfo>) -> Unit> = CFunc<(CPointer<Unit>, CPointer<CXIdxEntityRefInfo>) -> Unit>(CPointer<Int8>())
}

// cjlint-ignore -end cjbind